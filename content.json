{"meta":{"title":"Xjt5213's Blog","subtitle":null,"description":"不将就","author":"xjt5213","url":"https://www.xjt5213.club","root":"/"},"pages":[{"title":"分类","date":"2019-04-04T15:15:00.000Z","updated":"2019-04-04T15:25:37.689Z","comments":false,"path":"categories/index.html","permalink":"https://www.xjt5213.club/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-04T15:28:31.000Z","updated":"2019-04-04T15:30:06.425Z","comments":false,"path":"tags/index.html","permalink":"https://www.xjt5213.club/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-04T15:10:46.000Z","updated":"2019-04-04T15:31:18.061Z","comments":false,"path":"about/index.html","permalink":"https://www.xjt5213.club/about/index.html","excerpt":"","text":""},{"title":"日程表","date":"2019-04-04T15:13:06.000Z","updated":"2019-04-04T15:26:02.142Z","comments":false,"path":"schedule/index.html","permalink":"https://www.xjt5213.club/schedule/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-04T00:15:17.164Z","updated":"2019-04-04T00:15:17.164Z","comments":true,"path":"lib/jquery_lazyload/bower.json","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/bower.json","excerpt":"","text":"{\"name\":\"jquery_lazyload\",\"version\":\"1.9.4\",\"homepage\":\"http://www.appelsiini.net/projects/lazyload\",\"authors\":[\"Mika Tuupola \"],\"description\":\"jQuery plugin for lazy loading images\",\"main\":[\"jquery.lazyload.js\",\"jquery.scrollstop.js\"],\"license\":\"MIT\",\"ignore\":[\"**/.*\",\"**/*.min.js\",\"**/*.html\",\"**/*.textile\",\"Gruntfile.js\",\"lazyload.jquery.json\",\"package.json\",\"node_modules\",\"bower_components\",\"test\",\"img\"]}"},{"title":"","date":"2019-04-04T00:15:17.165Z","updated":"2019-04-04T00:15:17.165Z","comments":true,"path":"lib/jquery_lazyload/jquery.scrollstop.js","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/jquery.scrollstop.js","excerpt":"","text":"/* http://james.padolsey.com/javascript/special-scroll-events-for-jquery/ */ (function(){ var special = jQuery.event.special, uid1 = \"D\" + (+new Date()), uid2 = \"D\" + (+new Date() + 1); special.scrollstart = { setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } else { evt.type = \"scrollstart\"; jQuery.event.dispatch.apply(_self, _args); } timer = setTimeout( function(){ timer = null; }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid1, handler); }, teardown: function(){ jQuery(this).unbind( \"scroll\", jQuery(this).data(uid1) ); } }; special.scrollstop = { latency: 300, setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } timer = setTimeout( function(){ timer = null; evt.type = \"scrollstop\"; jQuery.event.dispatch.apply(_self, _args); }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid2, handler); }, teardown: function() { jQuery(this).unbind( \"scroll\", jQuery(this).data(uid2) ); } }; })();"},{"title":"","date":"2019-04-04T00:15:17.163Z","updated":"2019-04-04T00:15:17.163Z","comments":true,"path":"lib/jquery_lazyload/README.html","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/README.html","excerpt":"","text":"jquery-lazyload for NexT Installation Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-jquery-lazyload source/lib/jquery_lazyload Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1lazyload: true Update 12$ cd themes/next/source/lib/jquery_lazyload$ git pull"},{"title":"","date":"2019-04-04T00:15:17.165Z","updated":"2019-04-04T00:15:17.165Z","comments":true,"path":"lib/jquery_lazyload/jquery.lazyload.js","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/jquery.lazyload.js","excerpt":"","text":"/*! * Lazy Load - jQuery plugin for lazy loading images * * Copyright (c) 2007-2015 Mika Tuupola * * Licensed under the MIT license: * http://www.opensource.org/licenses/mit-license.php * * Project home: * http://www.appelsiini.net/projects/lazyload * * Version: 1.9.7 * */ (function($, window, document, undefined) { var $window = $(window); $.fn.lazyload = function(options) { var elements = this; var $container; var settings = { threshold : 0, failure_limit : 0, event : \"scroll\", effect : \"show\", container : window, data_attribute : \"original\", skip_invisible : false, appear : null, load : null, placeholder : \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" }; function update() { var counter = 0; elements.each(function() { var $this = $(this); if (settings.skip_invisible && !$this.is(\":visible\")) { return; } if ($.abovethetop(this, settings) || $.leftofbegin(this, settings)) { /* Nothing. */ } else if (!$.belowthefold(this, settings) && !$.rightoffold(this, settings)) { $this.trigger(\"appear\"); /* if we found an image we'll load, reset the counter */ counter = 0; } else { if (++counter > settings.failure_limit) { return false; } } }); } if(options) { /* Maintain BC for a couple of versions. */ if (undefined !== options.failurelimit) { options.failure_limit = options.failurelimit; delete options.failurelimit; } if (undefined !== options.effectspeed) { options.effect_speed = options.effectspeed; delete options.effectspeed; } $.extend(settings, options); } /* Cache container as jQuery as object. */ $container = (settings.container === undefined || settings.container === window) ? $window : $(settings.container); /* Fire one scroll event per scroll. Not one scroll event per image. */ if (0 === settings.event.indexOf(\"scroll\")) { $container.bind(settings.event, function() { return update(); }); } this.each(function() { var self = this; var $self = $(self); self.loaded = false; /* If no src attribute given use data:uri. */ if ($self.attr(\"src\") === undefined || $self.attr(\"src\") === false) { if ($self.is(\"img\")) { $self.attr(\"src\", settings.placeholder); } } /* When appear is triggered load original image. */ $self.one(\"appear\", function() { if (!this.loaded) { if (settings.appear) { var elements_left = elements.length; settings.appear.call(self, elements_left, settings); } $(\"\") .bind(\"load\", function() { var original = $self.attr(\"data-\" + settings.data_attribute); $self.hide(); if ($self.is(\"img\")) { $self.attr(\"src\", original); } else { $self.css(\"background-image\", \"url('\" + original + \"')\"); } $self[settings.effect](settings.effect_speed); self.loaded = true; /* Remove image from array so it is not looped next time. */ var temp = $.grep(elements, function(element) { return !element.loaded; }); elements = $(temp); if (settings.load) { var elements_left = elements.length; settings.load.call(self, elements_left, settings); } }) .attr(\"src\", $self.attr(\"data-\" + settings.data_attribute)); } }); /* When wanted event is triggered load original image */ /* by triggering appear. */ if (0 !== settings.event.indexOf(\"scroll\")) { $self.bind(settings.event, function() { if (!self.loaded) { $self.trigger(\"appear\"); } }); } }); /* Check if something appears when window is resized. */ $window.bind(\"resize\", function() { update(); }); /* With IOS5 force loading images when navigating with back button. */ /* Non optimal workaround. */ if ((/(?:iphone|ipod|ipad).*os 5/gi).test(navigator.appVersion)) { $window.bind(\"pageshow\", function(event) { if (event.originalEvent && event.originalEvent.persisted) { elements.each(function() { $(this).trigger(\"appear\"); }); } }); } /* Force initial check if images should appear. */ $(document).ready(function() { update(); }); return this; }; /* Convenience methods in jQuery namespace. */ /* Use as $.belowthefold(element, {threshold : 100, container : window}) */ $.belowthefold = function(element, settings) { var fold; if (settings.container === undefined || settings.container === window) { fold = (window.innerHeight ? window.innerHeight : $window.height()) + $window.scrollTop(); } else { fold = $(settings.container).offset().top + $(settings.container).height(); } return fold = $(element).offset().left + settings.threshold + $(element).width(); }; $.inviewport = function(element, settings) { return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) && !$.belowthefold(element, settings) && !$.abovethetop(element, settings); }; /* Custom selectors for your convenience. */ /* Use as $(\"img:below-the-fold\").something() or */ /* $(\"img\").filter(\":below-the-fold\").something() which is faster */ $.extend($.expr[\":\"], { \"below-the-fold\" : function(a) { return $.belowthefold(a, {threshold : 0}); }, \"above-the-top\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-screen\": function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-screen\" : function(a) { return !$.rightoffold(a, {threshold : 0}); }, \"in-viewport\" : function(a) { return $.inviewport(a, {threshold : 0}); }, /* Maintain BC for couple of versions. */ \"above-the-fold\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-fold\" : function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-fold\" : function(a) { return !$.rightoffold(a, {threshold : 0}); } }); })(jQuery, window, document);"}],"posts":[{"title":"vuex使用方式","slug":"vuex使用方式","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T12:32:53.337Z","comments":true,"path":"2019/07/26/vuex使用方式/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/vuex使用方式/","excerpt":"","text":"1 这段时间一直在用vue写项目，突然在网上看到一个新东西–vuex，和vue长得很像，于是就想把它弄懂，感觉在日后的开发中也有用先说一下vuex到底是什么??? 12&gt; vuex 是一个专门为vue.js应用程序开发的状态管理模式。&gt; 这个状态我们可以理解为在data中的属性，需要共享给其他组件中使用的部分，也就是说，我们需要共享的data，使用vuex来进行统一集中式的管理。 在vuex中，有默认的五种基本的对象： state：存储状态（变量） getters:对数据获取之前再次编译，可以理解为state的计算属性，我们在组件中使用$store.getters.fun() mutations:修改状态，并且是同步的，在组件中使用$store.commit(‘’,params),这个和我们组件中的自定义事件类似 actions：异步操作，在组件中使用的是$store.disapth(‘’) modules:store的子模块，为了开发大型项目，方便状态管理而使用的，这里我们就不解释了，用法和上边一样 下面，我们就正式开始，一步一步的使用vuex1 首先创建一个vue-cli项目1vue init webpack app 2 创建完成之后，我们进入文件夹下，并运行项目12cd appnpm run dev 3 接下来我们在src目录下新建一个文件夹vuex,同时在文件夹下创建一个store.js的文件目录层级类似下图 4 目前我们还没有引入vuex，先下载vuex,并且引入它 5 安装成功之后，在store.js中引入Vuex123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;export default new Vuex.Store(&#123; state&#125;) 6 在main.js中引入store1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'import store from './vuex/store' //引入storeVue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, //在实例上挂载store components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 然后我们就可以在任意一个组件中使用我们定义的count属性了 我们在helloworld.vue中使用一下 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;,&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 然后我们就可以在浏览器看到效果了 7 到这一步，vuex已经成功一小半了，回想一下，我们只需要安装使用vuex，在store.js中定义state对象，并且暴露出去，在main.js中使用我们的store.js(这里是为了防止在各个组件中引用，因为main.js中我们有new Vue({})实例)8 现在我们已经使用了state，接下来我们该如何操作这个值呢？没错，使用mutations和actions我们继续操作store.js文件，我们在store.js文件中定义mutations对象，该对象有两个方法，mutations里面的参数：第一个默认为state，第二个为自定义参数 我们在mutations中定义两个方法：增加和减少，并且设置一个参数为n,默认值为0，然后在Vuex.Store中使用它 1234567891011121314151617181920212223//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;//定义一个mutations对象const mutations = &#123; mutationsAddCount(state,n = 0)&#123; return state.count +=n; &#125;, mutationsReduceCount(state,n = 0)&#123; return state.count -=n; &#125;&#125;export default new Vuex.Store(&#123; state, mutations //使用mutations对象&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940//helloworld.vue&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;button @click=\"addCount(20)\"&gt;add&lt;/button&gt; &lt;button @click=\"reduceCount(30)\"&gt;reduce&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', methods:&#123; addCount(n)&#123; this.$store.commit('mutationsAddCount',n) &#125;, reduceCount(n)&#123; this.$store.commit(\"mutationsReduceCount\",n) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 来看一下浏览器效果如何 我们可以看到，每当我们出发事件时，都可以在浏览器中看到我们触发的mutations方法。 9 创建actions对象创建actions对象并使用 这里actions对象包含两个方法，两个方法中使用了不同的两个参数：一个是context,它是一个和store对象具有相同对象属性的参数，在第二个函数中，我直接使用了这个对象的commit方法，凭大家喜好就行 12345678910111213141516171819202122232425262728293031323334//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;const mutations = &#123; mutationsAddCount(state,n = 0)&#123; return state.count +=n; &#125;, mutationsReduceCount(state,n = 0)&#123; return state.count -=n; &#125;&#125;const actions = &#123; actionsAddCount(context,n = 0)&#123; return context.commit('mutationsAddCount',n) // return state.count +=n &#125;, actionsReduceCount(&#123;commit&#125;,n = 0)&#123; return commit('mutationsReduceCount',n) // return state.count -=n &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//helloworld.vue&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addCount(20)&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;reduceCount(30)&quot;&gt;reduce&lt;/button&gt; &lt;button @click=&quot;syncAddCount(10)&quot;&gt;异步增加&lt;/button&gt; &lt;button @click=&quot;syncReduceCount(20)&quot;&gt;异步减少&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;, methods:&#123; addCount(n)&#123; this.$store.commit(&apos;mutationsAddCount&apos;,n) &#125;, reduceCount(n)&#123; this.$store.commit(&quot;mutationsReduceCount&quot;,n) &#125;, syncAddCount(n)&#123; this.$store.dispatch(&apos;actionsAddCount&apos;,n) &#125;, syncReduceCount(n)&#123; this.$store.dispatch(&apos;actionsReduceCount&apos;,n) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 在helloworld.vue中，在methods中，增加两个方法，使用dispath()来触发，最后的效果就是上图所示。 10 最后就是getters我们一般使用getters来获取我们的state,因为它算是state的一个计算属性 12345678910111213//store.jsconst getters = &#123; getterCount(state,n = 0)&#123; return state.count +=n; &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 1&lt;h4&gt;&#123;&#123;count&#125;&#125;&lt;/h4&gt; 12345const getters = &#123; getterCount(state) &#123; return (state.count += 10) &#125;&#125; getter算是非常简单的了，到这里如果全都看懂了，vuex你已经没有压力了 但是vuex官方给了我们一个更加简单的方式来使用vuex，也就是{mapState, mapMutations, mapActions, mapGetters} 只要我们把上边的基础搞懂，这些都不在话下，只是方便我们书写罢了 就这么简单，这里我们用到了ES6的拓展运算符，如果部署下的同学建议去看看阮一峰的《ES6入门标准》这本书 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt;import &#123;mapState, mapMutations, mapActions, mapGetters&#125; from &apos;vuex&apos;export default &#123; name: &apos;HelloWorld&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, methods: &#123; ...mapMutations(&#123; handleAddClick: &apos;mutationsAddCount&apos;, handleReduceClick: &apos;mutationsReduceCount&apos; &#125;), ...mapActions(&#123; handleActionsAdd: &apos;actionsAddCount&apos;, handleActionsReduce: &apos;actionsReduceCount&apos; &#125;) // handleAddClick(n)&#123; // this.$store.commit(&apos;mutationsAddCount&apos;,n); // &#125;, // handleReduceClick(n)&#123; // this.$store.commit(&apos;mutationsReduceCount&apos;,n); // &#125;, // handleActionsAdd(n)&#123; // this.$store.dispatch(&apos;actionsAddCount&apos;,n) // &#125;, // handleActionsReduce(n)&#123; // this.$store.dispatch(&apos;actionsReduceCount&apos;,n) // &#125; &#125;, computed: &#123; count()&#123; return this.$store.getters.getterCount &#125; &#125;&#125;&lt;/script&gt; 同理，getters和 state也可以使用 mapState，mapGetters 最后，如果本文有什么错误的地方，欢迎在下方评论区指出，不胜感激！！！","categories":[],"tags":[{"name":"学习笔记，教程","slug":"学习笔记，教程","permalink":"https://www.xjt5213.club/tags/学习笔记，教程/"}]},{"title":"js事件冒泡及事件捕获","slug":"js事件冒泡及捕获","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T03:22:43.184Z","comments":true,"path":"2019/07/26/js事件冒泡及捕获/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/js事件冒泡及捕获/","excerpt":"","text":"DOM事件流存在三个阶段：即事件捕获阶段、出于目标阶段、事件冒泡阶段事件捕获：通俗的理解就是，当鼠标点击或者触发DOM事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获的方式注册了对应事件的话，就会先触发父元素绑定的事件。 事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内向外进行事件传播。 无论是事件捕获还是事件冒泡，它们都有一个共同的行为：那就是事件传播。它就像是一根引线，只有通过引线，才能将绑定在引线上的鞭炮（事件监听器）引爆。 DOM标准事件流的触发先后顺序为先捕获再冒泡，即当触发DOM事件时，先进行事件捕获，捕获到事件源时候通过事件传播进行事件冒泡，不同的浏览器对此有着不同的实现，ie10及以下不支持事件捕获，所以就少了一个事件捕获阶段；IE11，Chrome，Firefox，Safari等浏览器则同时存在。 说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent。当然还有其它的事件绑定的方式这里不做介绍。 ​ addEventListener(event, listener, useCapture) ​ ·参数定义：event—（事件名称，如click，不带on） ​ listener—事件监听函数 ​ useCapture—*是否采用事件捕获进行事件捕捉，默认为false，即采用事件冒泡方式 ​ attachEvent(event,listener) ​ ·参数定义：event—（事件名称，如onclick，带on） ​ listener—事件监听函数。 attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了（微软还是挺识趣的，慢慢向标准靠拢）。 事件冒泡例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent&#123; width: 200px; height:200px; text-align: center; line-height: 3; background: green; &#125; #child&#123; width: 100px; height: 100px; margin: 0 auto; background: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"parent\"&gt; 父元素 &lt;div id=\"child\"&gt; 子元素 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); document.body.addEventListener('click',function () &#123; console.log(\"click-body\") &#125;,false) parent.addEventListener('click',function () &#123; console.log('click-parent') &#125;,false) child.addEventListener('click',function () &#123; console.log('click-child') &#125;,false)&lt;/script&gt; 通过addEventListener方法，采用事件冒泡方式给DOM元素注册事件，点击子元素会发生什么呢？如果你对事件冒泡有一定的了解的话，name你一定会知道上面代码的输出顺序，如下图所示： 事件触发顺序是由内到外的，这就是事件冒泡，虽然只点击子元素，但是它的父元素也会触发相应的事件，其实这是合理的，因为子元素在父元素里面，点击子元素也就相当于变相的点击了父元素，这样理解对吧？ 这里有同学可能要问了，如果点击子元素不想触发父元素的事件怎么办？肯定可以的，那就是停止事件传播—event.stopPropagation(); 修改例子1的代码，在子元素的事件监听函数中加入停止事件冒泡的操作，示例2. 1234child.addEventListener('click',function (e) &#123; console.log('click-child') e.stopPropagation() &#125;,false) 在改变上述代码之后，点击子元素，浏览器控制台将输出什么呢，如图： 由于手动停止了事件冒泡，所以点击子元素的时候就只触发了子元素的click方法，并没有触发父元素及body的，冒泡阶段也就停止了。 讲完了事件冒泡，接下来讲一下事件捕获，请看示例 修改例子1中的代码，给parent元素注册一个捕获事件 123456789101112var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); document.body.addEventListener('click',function () &#123; console.log(\"click-body\") &#125;,false) parent.addEventListener('click',function () &#123; console.log('click-parent') &#125;,true) child.addEventListener('click',function (e) &#123; console.log('click-child') &#125;,false) 看明白我说的那些，就知道上面的代码输出顺序了： 父元素通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，然后到了目标阶段，即事件源，之后进行事件传播，parent同时也用冒泡方式注册了click事件，所以这里会触发冒泡事件，最后到根节点。这就是整个事件流程。 上面介绍了事件冒泡、事件捕获、事件传播，下面讲一下如何通过以上三个知识点进行事件委托 委托在JQuery中已经得到了实现，即通过$(*selector*).on(*event,childSelector,data,function,map*)实现委托，一般用于动态生成的元素，当然JQuery也是通过原声的js去实现的，下面举一个简单的栗子，通过js实现通过parent元素给child元素注册click事件 1234567var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); parent.onclick = function (e) &#123; if (e.target.id == 'child')&#123; console.log('click-child'); &#125; &#125; 虽然没有直接只child元素注册click事件，可是点击child元素时却弹出了提示信息。 到这里是不是对js的事件机制有一定的了解了呢？感觉有帮助的话就看看下面的小黄脸，你懂得哦！ 如有错误，欢迎指正 如有问题，欢迎提问","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"v-model是什么?怎么使用？vue中标签如何绑定事件","slug":"v-model使用及标签绑定事件","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T07:28:52.604Z","comments":true,"path":"2019/07/26/v-model使用及标签绑定事件/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/v-model使用及标签绑定事件/","excerpt":"","text":"引用官方文档的一段话 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 v-moidel在内部为不同的输入元素使用不同的属性并跑出不同的时间 text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" value=\"篮球\" id=\"basketball\" v-model=\"message\" checked&gt; &lt;label for=\"basketball\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" value=\"足球\" id=\"football\" v-model=\"message\"&gt; &lt;label for=\"football\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" value=\"羽毛球\" id=\"yumao\" v-model=\"message\"&gt; &lt;label for=\"yumao\"&gt;羽毛球&lt;/label&gt; &lt;div&gt;你的选择是：&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; $(function () &#123; new Vue(&#123; el:\"#app\", data:&#123; message:[] &#125; &#125;) &#125;)&lt;/script&gt; 所谓数据的双向绑定，指的就是我们在js中的vue实例中的data与其渲染的dom元素上的内容保持一致，两者无论谁被改变，另一方也会相应的更新为相同的数据。这是通过设置属性访问器实现的。 2. vue中标签如何绑定事件可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 1234&lt;div id=\"example-2\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"利用oneindex将onedrive打造成一个在线查看和下载文件的网盘","slug":"v2ray搭建教程及使用方法","date":"2019-07-11T09:01:57.614Z","updated":"2019-07-11T09:02:58.901Z","comments":true,"path":"2019/07/11/v2ray搭建教程及使用方法/","link":"","permalink":"https://www.xjt5213.club/2019/07/11/v2ray搭建教程及使用方法/","excerpt":"","text":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.xjt5213.club/tags/教程/"}]},{"title":"Linux命令学习","slug":"linux常用命令","date":"2019-06-26T16:00:00.000Z","updated":"2019-06-27T05:59:20.802Z","comments":true,"path":"2019/06/27/linux常用命令/","link":"","permalink":"https://www.xjt5213.club/2019/06/27/linux常用命令/","excerpt":"","text":"话不多说直接上命令哈哈哈哈Linux常用命令 1. 目录操作命令 \\1. ls:显示当前目录下的文件（不包含隐藏文件） \\2. ls 目录名：显示指定目录下的文件 \\3. ls -l :列出文件的详细信息 \\4. ls -l 文件名：显示指定文件的详细信息 \\5. ls -a:显示当前目录下的所有文件（包含了隐藏文件） \\6. cd 绝对路径：进入到指定路径 \\7. cd ~ : 进入到当前用户的家目录 \\8. cd .. : 进入到上一级目录 \\9. cd / : 返回根目录 \\10. cd ./当前目录下的其他文件夹:进入当前目录下的其他目录 \\11. pwd : 显示当前所在的目录 \\12. mkdir 自定义目录名：例如-mkdir test 在当前目录下创建名为test的目录 \\13. mkdir -p 递归路径：例如mkdir -p test1/test2/test3 \\14. rmdir 目录名 ：删除目录（只能删除空目录） 2. 文件操作命令 \\1. touch: 创建空文件（文件不存在时）或者修改文件时间（文件存在时修改文件时间） \\2. rm 文件名：删除文件 \\3. rm -f 文件名：强制删除文件 \\4. rm -rf 目录名：强制删除目录和文件 \\5. cat 文件名：查看文件内容 \\6. cp 源文件 目标位置：复制文件到指定目录 \\7. cp -r 目录名 目标位置：复制目录到指定目录 \\8. mv 源文件 目标位置： 例如：mv /root/test /tmp/ 将/root/下的test文件移动到/tmp/目录下 mv /root/test /root/newtest 将/root/下的test文件改名为newtest 3. 查找命令 \\1. find 查找位置 -name 文件名： \\2. whereis 文件名：查找文件，同时列出文件路径 \\3. Which ：用于查找可执行命令，只能查找可执行文件， 例如which ls 4. 编辑命令 \\1. Vi 文件名：编辑文件 \\1. Ins 进入编辑模式 \\2. Esc 退出编辑模式，进入命令模式 \\3. \\2. vim 文件名：用法与vi类似 \\3. nano 文件名： \\4. 换源 Yum工具：换源路径： /etc/yum.repos.d/CentOS-Base.repo yum makecache：更新软件包缓存 Apt工具：换源路径： /etc/apt/sources.list Apt-get update :更新缓存","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"vue-router使用步骤","slug":"vue-router使用步骤详解","date":"2019-06-25T16:00:00.000Z","updated":"2019-07-26T05:59:43.816Z","comments":true,"path":"2019/06/26/vue-router使用步骤详解/","link":"","permalink":"https://www.xjt5213.club/2019/06/26/vue-router使用步骤详解/","excerpt":"","text":"最近在学习vue框架，一直对vue中的路由使用步骤不太明白，于是就写一篇关于vue-router的使用步骤吧 1. 安装vue-router（使用npm安装）1npm install vue-router --save 2. 在vue组件内配置router-link和router-view router-link:映射路由.就是创建a标签来定义路由导航的链接(用户通过点击实现跳转).通过to属性指定目标地址.默认渲染成带有正确链接的标签. router-view:就是在标签内渲染你路由匹配到的视图组件.router-view支持嵌套router-view,并且支持多个router-view分别渲染不同的component. 具体用法如下 12345678&lt;!--这里引用官方例子的写法--&gt;&lt;div id='app'&gt; &lt;p&gt; &lt;router-link to=\"/user/foo\"&gt;/user/foo&lt;/router-link&gt; &lt;router-link to=\"/user/bar\"&gt;/user/bar&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;PS:写在这里,即router-view里的内容是不会显示在页面上的!&lt;/router-view&gt;&lt;/div&gt; 3. 配置路由实例index.js1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from &apos;vue&apos; //第一步，引入必要的文件vue,加载全局组件时使用import Router from &apos;vue-router&apos; //第二步，引入vue-router//第三步. 加载路由组件import Main from &quot;../components/Main/Main&quot;;import aboutus from &quot;../components/aboutus/aboutus&quot;import like from &quot;../components/like/like&quot;import news from &quot;../components/news/news&quot;import reverse from &quot;../components/reverse/reverse&quot;//第四步，加载全局组件RouterVue.use(Router)//第五步，配置路由实例export default new Router(&#123; linkActiveClass:&apos;active&apos;, //为当前选中的router-link组件添加active routes: [ &#123; path: &apos;/&apos;, redirect:&quot;/Main&quot;, //设置重定向 component: Main &#125;, &#123; path: &apos;/Main&apos;, component: Main &#125;, &#123; path:&apos;/aboutus&apos;, component:aboutus &#125;, &#123; path:&apos;/like&apos;, component:like &#125;, &#123; path:&apos;/news&apos;, component:news &#125;, &#123; path:&apos;/reverse&apos;, component:reverse &#125; ]&#125;) 4. 在main.js中引入router.js并挂载到vue实例上1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router' //引入router.jsimport $ from 'jquery'import 'bootstrap'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, //挂载到vue实例，这个是简写，全称是router：router components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 5. 区分一下router，routes，route? router:一般指的就是路由实例.如$router. routes:指router路由实例的routes API.用来配置多个route路由对象. route:指的就是路由对象.例如;$route指的就是当前路由对象.","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"HTML/CSS基础总结（1）","slug":"htmlcss面试基础题（1）","date":"2019-06-19T16:00:00.000Z","updated":"2019-06-20T10:31:51.401Z","comments":true,"path":"2019/06/20/htmlcss面试基础题（1）/","link":"","permalink":"https://www.xjt5213.club/2019/06/20/htmlcss面试基础题（1）/","excerpt":"","text":"1.列出display的值，说明他们的作用。 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。 list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示，表格前后带有换行符。 inline-table 此元素会作为内联表格来显示，表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示 table-header-group 此元素会作为一个或多个行的分组来显示 table-footer-group 此元素会作为一个或多个行的分组来显示 table-row 此元素会作为一个表格行显示 table-column-group 此元素会作为一个或多个列的分组来显示 table-column 此元素会作为一个单元格列显示 table-cell 此元素会作为一个表格单元格显示 table-caption 此元素会作为一个表格标题显示 inherit 规定应该从父元素继承 display 属性的值。 2.position的值：relative和absolute的定位原点是？ absolute：绝对定位，定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点。 relative：相对定位，定位原点是元素本身所在的位置。 3.CSS3有哪些新特性？ 圆角border-radius:值通常有px、rem、em、%（基于元素的width和height表示）。 1，当为一个值时：表示所有的角都为这个值 2，当为两个值时，表示左上，右下角相等、右上、左下角相等 3，当为三个值时，第一个值为左上角，第二个值为左下、右上角，第三个值为右下角 4，当为多个值时，可以为所有的角都设置值，从左上角开始 5，当用/来表示时，/前面的为水平半径，/后的为垂直半径","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"清除浮动的几种方法","slug":"清除浮动的方法","date":"2019-04-12T06:43:45.000Z","updated":"2019-04-12T08:33:27.352Z","comments":true,"path":"2019/04/12/清除浮动的方法/","link":"","permalink":"https://www.xjt5213.club/2019/04/12/清除浮动的方法/","excerpt":"","text":"今天在班上分享几种清除浮动的方法，讲到一半突然忘了，贼尴尬，于是自己在网上找了几种解决办法来清除浮动 先看一段代码—-html 123456&lt;body&gt; &lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 再给一段css代码 1234567891011121314151617&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float:left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float:left; &#125; &lt;/style&gt; 上面代码中我分别给了两个子div一个float：left;于是他们就向左浮动，出现在一行了；看看下图效果 从中可以看到，当我给两个子div分别设置向左浮动之后，可以看看右下角的盒子模型，父div的高度变成了0，这是为什么呢？ 情况是这样的，当我们分别给两个子div设置float:left;之后，子就会脱离文档流，不在占有页面位置了，所以我们看到的高度为0了 那么我们应该怎样解决这种情况呢（在不删除float:left;的情况下）？？ 在网上找了几种解决办法： 1，利用clear:both;1，在父级下面增加一个空标签，设置css属性为clear:both;。看代码—css 1234567891011121314151617181920&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; + .myDiv03&#123; + clear: both; + &#125; &lt;/style&gt; html 1234567&lt;body&gt; &lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; + &lt;div class=\"myDiv03\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 最后看效果 可以看到加上上面代码之后，在看右下角的盒子模型，父级的高度变成了200px;也就是说生效了。 2，直接给父级具体的宽和高我们可以直接给父级一个具体的宽高，之前我们是没有给父级宽度和高度的，父级的宽度和高度是由子撑开的 ，下面我们给父级一个具体的宽度和高度 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 1234567891011121314151617181920&lt;style type=\"text/css\"&gt; .myDiv&#123; + width: 500px; + height: 300px; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 给了之后来看效果 给了具体的宽高之后，右下角的盒子模型里面父级的宽度和高度就是css代码里面我给的宽高了，所以这种方法也可行 3，利用伪元素：：after我们还可以利用伪元素::after来达到清除浮动的效果，直接上代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125;+ .myDiv::after&#123;+ content: \"\";+ width: 0;+ height: 0;+ visibility: hidden;+ display: block;+ &#125; &lt;/style&gt; 来看一下效果是什么样子的 利用伪元素::after之后也可以解决 ，原理是通过清除伪元素的浮动，达到撑起父元素高度的目的。注意到该伪元素的display类型为block,他是一个不可见的块级元素。其原理跟方法一类似。 4，利用overflow来清除浮动我们可以直接给父元素一个overflow:hidden;或者overflow:auto样式，来看看代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red;+ overflow: hidden; /*用overflow:auto;也行*/ &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 我们来看看效果 这个原理的话暂时还没弄明白，等后面弄明白了再来更新吧！！！ 5，给父级也添加float:left;属性也可以直接给父级一个float:left;样式属性 看代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; float: left; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 我们来看效果 当给父级一个float:left;之后，父级的高度也被撑开了，但是这种做法使得父级也脱离了文档流，虽然方便，但是对页面的布局不是很友好，不易维护。 以上就是我总结的五种清除浮动的方法，可能有些地方总结不到位，有则指出，无则加冕，感谢！","categories":[],"tags":[]},{"title":"元素js获取css样式","slug":"原生js获取css样式","date":"2019-04-08T02:39:39.000Z","updated":"2019-04-10T03:18:25.769Z","comments":true,"path":"2019/04/08/原生js获取css样式/","link":"","permalink":"https://www.xjt5213.club/2019/04/08/原生js获取css样式/","excerpt":"","text":"最近在写js代码的时候碰到了一个问题：用原生js并不能完全获取css样式属性。 1，内部样式表情况12document.getElementsByTagName(\"div\")[0].style.backgroundColor=\"green\"; //可以写入样式console.log(document.getElementsByTagName(\"div\")[0].style.width); //不能够获取样式属性 当用内部样式表的时候用这种方式的时候只能给css写入样式，并不能获取css样式。 2，内联样式情况12document.getElementsByTagName(\"div\")[0].style.backgroundColor=\"green\"; //可以写入样式console.log(document.getElementsByTagName(\"div\")[0].style.width); //能够获取样式属性 当使用内部样式表的时候，采用上面的js代码既可以获取样式属性，还可以给标签写入样式，但是使用内联样式的话会使得html代码显得很繁琐，没有规则，所以不推荐。 后来在网上查找了一些方法，发现了几种解决办法 方法一，使用window.getComputedStyle(参数一，参数二); 参数一：元素，参数二：当前元素的伪类，一般写null 12var divs=document.getElementsByTagName(\"div\")[0];console.log(window.getComputedStyle(divs,null).width); //获取宽度 这个方法在ie6-8上面不兼容，获取的内容为只读，并不能写入，所以我又找了一种方法 方法二，在ie上使用currentStyle属性","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"http深入浅出--http请求","slug":"学习笔记一--Http请求","date":"2019-04-08T02:39:39.000Z","updated":"2019-04-08T03:02:12.858Z","comments":true,"path":"2019/04/08/学习笔记一--Http请求/","link":"","permalink":"https://www.xjt5213.club/2019/04/08/学习笔记一--Http请求/","excerpt":"","text":"HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务，HTTP目前协议的版本是1.1.HTTP是一种无状态的协议，无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP使用内容类型，是指Web服务器向Web浏览器返回的文件都有与之相关的类型。所有这些类型在MIME Internet邮件协议上模型化，即Web服务器告诉Web浏览器该文件所具有的种类，是HTML文档、GIF格式图像、声音文件还是独立的应用程序。大多数Web浏览器都拥有一系列的可配置的辅助应用程序，它们告诉浏览器应该如何处理Web服务器发送过来的各种内容类型。 HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：1,建立TCP连接在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80 2,Web浏览器向Web服务器发送请求命令一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令 例如：GET/sample/hello.jsp HTTP/1.1 3,Web浏览器发送请求头信息浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 4,Web服务器应答客户机向服务器发出请求后，服务器会客户机回送应答。eg: HTTP/1.1 200 OK 5，Web服务器应答头信息正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 6,Web服务器向浏览器发送数据Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 7,Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"利用oneindex将onedrive打造成一个在线查看和下载文件的网盘","slug":"oneindex教程","date":"2019-04-07T12:03:21.000Z","updated":"2019-04-07T15:07:34.541Z","comments":true,"path":"2019/04/07/oneindex教程/","link":"","permalink":"https://www.xjt5213.club/2019/04/07/oneindex教程/","excerpt":"","text":"之前弄了一个onedrive账号，专门用来存一些电影，容量是5T，挺大的，用oneindex来将onedrive打造成一款可以在线观看和下载视频或者文件的一个小网站最好不过了 1，注册免费空间我用的是000webhost,所以我就拿这个来做了，附上注册链接：https://www.000webhost.com/free-website-sign-up 填写邮箱和密码就可以注册了，是不是非常简单…….. 2，网站后台接下来登陆进入后台会看到大概如图所示的样子，点击Manage Websites管理网站 点进去之后就是这个样子 ,然后点击File manager 出现这个 点击Upload files now 出现下图 3，oneindex部署先附上oneindex下载地址:https://github.com/donwa/oneindex 下载完成后,点击这个上传按钮把刚下的压缩包上传即可 注意：是上传至public_html文件夹下 上传完了之后，网站目录下就会出现这个压缩包了 然后右键单击压缩包解压 注意：还是解压至public_html目录下，可能因为某些原因压缩包解压不了，那么只能在本地解压了，然后把文件和文件夹一个一个地上传到该目录下，注意空文件夹也要上传哦 解压完或者上传完之后的文件大概是这个样子的 这个时候oneindex就部署完了 4，oneindex设置点击你的网址就会看到oneindex的设置界面了 下一步即可 然后获取应用id和机密分别填入第一栏和第二栏，第三栏不动 下一步。 绑定账号之后刷新你的网址就可以了 安装完成后可以通过后台登录对OneIndex进行管理 后台网址：你的原有网址上+/?/admin即可，初次登陆需要密码，默认密码是oneindex 上传文件到你的onedrive就可以在这个网站上同步显示了，如果是视频可以在线观看 5，指定文件夹加密如果你要给你的网站加密码，只有输入密码才能访问的话，win+R输入cmd 进入到你的桌面路径 在弹出的命令行输入echo 你设置的密码-&gt;password回车 在你的桌面会出现一个后缀为.password的文件，把这个文件放入你想加密的文件夹里面，到oneindex后台刷新缓存之后重新进入你的网站就会要求输入密码访问了。 6，文件上传上传文件的话直接用onedrive上传即可，刷新你的网站即可看到上传的文件。","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.xjt5213.club/tags/教程/"}]},{"title":"自建爬梯教程","slug":"爬梯教程","date":"2019-04-06T09:37:08.000Z","updated":"2019-04-08T09:50:56.135Z","comments":true,"path":"2019/04/06/爬梯教程/","link":"","permalink":"https://www.xjt5213.club/2019/04/06/爬梯教程/","excerpt":"","text":"之前自建爬梯的时候老是自己在网上找教程，非常啰嗦，所以写一篇搭建教程，为了以后的方便吧 1，注册vps首先你得有一个vps,至于是什么vps,本人不才，用的vultr，其实很多人都说vultr现在不好用了，过于泛滥，其实我觉得还行吧，可能是挺早之前买的缘故吧，听说后面买的比较容易被盯上。话不多说，开始上教程。首先，去注册一个vultr账号，其他的vps也一样需要注册账号，附上链接：https://www.vultr.com/然后在下图中填上你要注册的邮箱和密码点击Create Account就可以了,是不是特别简单。 2，充值在注册完成之后，就要给vultr充值了，用来购买套餐，vultr充值方式比较多，支持国内的支付宝和微信支付，首次登陆之后出现的界面就是充值界面了,选择你需要的充值方式进行充值即可 选择好充值方式和充值金额之后，点击下方的充值按钮进行支付就行了 3，套餐选择充值完成之后，点击左侧栏的第一个进行服务器购买 1，Server Location：是选择机房的位置，一般来说是离大陆越近越好，我选择的是日本机房，根据你们的情况自行选择即可 2,Server Type:是选择vps需要装的系统,一般来说选择centos或者Debian就可以了，我选择的是Debian9x64的，你们根据实际情况自行选择 3,Server Size:这里选择服务器的内存和月流量，如果你是一个人用的话推荐月付$3.5的或者$5的套餐即可 上面步骤执行完之后，下面的那些内容就不用管了，直接点击最下方的Deploy now即可 等待几分钟之后会出现下图所示点击服务器，会进入到详细页面,下图所示是一般需要了解的地方 4，登陆vps后台进行配置这里我们需要下载一个软件叫xshell,xftp也可以，我用的是xshell,你们根据自己的需要自行选择，附上链接https://www.netsarang.com/zh/free-for-home-school/这个是免费版，填上你的姓名和邮箱之后会把下载链接发送到你的邮箱进行下载即可，下载完之后安装打开,点击新建 上面填入你的主机名，即IP地址，填完之后点击左侧的用户身份验证 验证之后会跳到另一个页面，上面填写你的用户名root，和密码（密码在vps详情页面信息可以看到，教程上面有截图），填完之后点击下方的连接即可,在之后弹出的对话框中选择一次性接受就可以了 不出意外的话，右侧的命令行最下方会出现root字样的一行，说明你成功登陆了 5，脚本安装(敲黑板，重点来了！！！！)成功登陆之后，就可以开始梯子的脚本安装了，我用的是GitHub上一位大牛的一键脚本(教程最后附上链接，有需要的朋友可以去看看)，一键傻瓜式安装即可，在命令行输入以下命令然后回车安装即可 5.1安装&amp;更新命令1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh 5.2自检命令（没啥用，可以省略）1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/self-check.sh &amp;&amp; bash self-check.sh 5.3卸载命令1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh uninstall 执行完上面的安装命令之后，然后在命令行输入ssr就可以运行脚本了,输入对应的数字就可以进行操作了 输入数字6回车,会提示输入用户名，密码，流量（每输入一个都要回车哦） 上面的步骤做完之后，一个梯子节点就生成了，往上拉一点，应该会出现下图相似的信息,复制标注的这段代码。 6，节点的使用6.1,手机使用如果你想在手机上使用的话。下载这个软件。下载地址：https://github.com/shadowsocksrr/shadowsocksr-latest-bin-backup/raw/master/Shadowsocksr-android-3.4.0.5.apk下载完成后打开 点击右下角+号，有个从剪切板导入，把刚刚复制的代码导入就行了，注意路由选择绕过局域网及中国大陆地址，不然访问国内的软件也会走vps流量哦 6.2，电脑使用如果你想在电脑上使用的话。下载这个软件。下载地址：https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip下载完成后解压，打开解压的文件夹，双击如图所示的图标之后右下角的任务栏会有小飞机的图标，鼠标右键单击这个图标，会有剪切板批量导入ssr:链接，还是复制刚才那段代码选择导入即可，导入完成之后注意系统代理模式选择PAC,代理规则选择绕过局域网和大陆即可 本教程的一键安装脚本由GitHub大佬提供，附上大佬链接https://github.com/FunctionClub/SSR-Bash-Python有需要的朋友可以去看看哦 本人第一次写教程，写的不好的地方欢迎在下方提出，以便以后可以改进，感谢哦","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.xjt5213.club/tags/教程/"}]},{"title":"开篇随笔","slug":"开篇随笔","date":"2019-04-01T09:19:37.000Z","updated":"2019-04-05T05:08:23.057Z","comments":true,"path":"2019/04/01/开篇随笔/","link":"","permalink":"https://www.xjt5213.club/2019/04/01/开篇随笔/","excerpt":"","text":"历经了各种艰难险阻（其实是自己太水），才完成这个blog的搭建，可以说是一个小小白了，搭建的过程中各种碰壁，不过最终还是完了，感觉内心还是蛮有成就感的，最近在开始接触前端知识，以后这个地方就作为我写一点学习笔记的地方吧，分享算不上，前面说了是小小白哈哈哈。目前大四，正处于找工作的黄金时期，其实静下心来学习是一件非常不容易的事情，当你的同学室友都纷纷出去找工作实习去了，而你还在上课，其实我的内心是非常焦灼的，然而没办法。只恨当初在学校的时候没有好好学习，手动留下悔恨的泪水表情包。至于为什么选择入前端这个行业，其实我自己也说不清，通俗点来讲的话是比较容易入门吧。其实在这之前自学过一段时间java，说说自学的感想吧，每天看视频，码代码，刚开始还是挺有兴趣的，可是到后来慢慢的就坚持不下去了，没有学习的氛围真的会让我坚持不下去，不知道你们会不会这样，就这样自学了不到一个月就不了了之了，然后就转前端了。。。。再讲一下去年秋招面试的各种经历吧，总结成四个字就是四处碰壁。当时刚开始的想法是找一个开发岗位的工作，信心满满，没错是梁静茹给我的勇气，跑各大学校的招聘会，在现场跟面试官交流的过程中，面试官问我有没有做过项目，我说没有。。。。。然后又问了一些关于框架的知识，我都是一脸懵，然后把简历留在那里说等通知，自己灰溜溜的走了，后来才意识到自己在这方面的不足，基本上每次面试都逃不过这两个问题。当时就感觉有点人生充满了绝望，当时是出于这样一种情况，想找一个好工作，可是水平又打不到。后来于是降低了标准，不找开发岗了，找一个技术支持岗吧，又开始在各大招聘网站上广撒网，等面试通知，后来找到一个相关工作，整天坐在电脑面前帮客户解决各种售前售后问题，一个人得照看三台电脑，工作了刚好一个星期，突然某一天快下班的时候被人事经理叫过去谈话，说我一个人照看三台电脑有点吃力，可能是不太适合这份工作，so……我第一次被炒……也没有很失望，本来我自己就不喜欢那份工作，无所谓。然后就回家过年了哈哈哈哈，心真大。说真的 ，找一份自己感兴趣的工作真的非常重要。诶！不说了，都是泪。其实我感觉我对计算机挺感兴趣的，每次做完一个东西都感觉特别有成就感，尽管在某些大牛眼里是一个非常普通的东西。但是同时也不知道自己是不是真的适合干这个行业，还是那句话，不管结果如何，自己尽力了就好。 ps:不知道写点啥了，以后想起来再写吧，希望最后活成自己想要的样子。","categories":[],"tags":[]}]}