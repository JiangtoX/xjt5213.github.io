{"meta":{"title":"Xjt5213's Blog","subtitle":null,"description":"不将就","author":"xjt5213","url":"https://www.xjt5213.club","root":"/"},"pages":[{"title":"关于","date":"2019-04-04T15:10:46.000Z","updated":"2019-04-04T15:31:18.061Z","comments":false,"path":"about/index.html","permalink":"https://www.xjt5213.club/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-04T15:15:00.000Z","updated":"2019-04-04T15:25:37.689Z","comments":false,"path":"categories/index.html","permalink":"https://www.xjt5213.club/categories/index.html","excerpt":"","text":""},{"title":"日程表","date":"2019-04-04T15:13:06.000Z","updated":"2019-04-04T15:26:02.142Z","comments":false,"path":"schedule/index.html","permalink":"https://www.xjt5213.club/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-04T15:28:31.000Z","updated":"2019-04-04T15:30:06.425Z","comments":false,"path":"tags/index.html","permalink":"https://www.xjt5213.club/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-04T00:15:17.164Z","updated":"2019-04-04T00:15:17.164Z","comments":true,"path":"lib/jquery_lazyload/bower.json","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/bower.json","excerpt":"","text":"{\"name\":\"jquery_lazyload\",\"version\":\"1.9.4\",\"homepage\":\"http://www.appelsiini.net/projects/lazyload\",\"authors\":[\"Mika Tuupola \"],\"description\":\"jQuery plugin for lazy loading images\",\"main\":[\"jquery.lazyload.js\",\"jquery.scrollstop.js\"],\"license\":\"MIT\",\"ignore\":[\"**/.*\",\"**/*.min.js\",\"**/*.html\",\"**/*.textile\",\"Gruntfile.js\",\"lazyload.jquery.json\",\"package.json\",\"node_modules\",\"bower_components\",\"test\",\"img\"]}"},{"title":"","date":"2019-04-04T00:15:17.165Z","updated":"2019-04-04T00:15:17.165Z","comments":true,"path":"lib/jquery_lazyload/jquery.scrollstop.js","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/jquery.scrollstop.js","excerpt":"","text":"/* http://james.padolsey.com/javascript/special-scroll-events-for-jquery/ */ (function(){ var special = jQuery.event.special, uid1 = \"D\" + (+new Date()), uid2 = \"D\" + (+new Date() + 1); special.scrollstart = { setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } else { evt.type = \"scrollstart\"; jQuery.event.dispatch.apply(_self, _args); } timer = setTimeout( function(){ timer = null; }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid1, handler); }, teardown: function(){ jQuery(this).unbind( \"scroll\", jQuery(this).data(uid1) ); } }; special.scrollstop = { latency: 300, setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } timer = setTimeout( function(){ timer = null; evt.type = \"scrollstop\"; jQuery.event.dispatch.apply(_self, _args); }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid2, handler); }, teardown: function() { jQuery(this).unbind( \"scroll\", jQuery(this).data(uid2) ); } }; })();"},{"title":"","date":"2019-04-04T00:15:17.163Z","updated":"2019-04-04T00:15:17.163Z","comments":true,"path":"lib/jquery_lazyload/README.html","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/README.html","excerpt":"","text":"jquery-lazyload for NexT Installation Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-jquery-lazyload source/lib/jquery_lazyload Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1lazyload: true Update 12$ cd themes/next/source/lib/jquery_lazyload$ git pull"},{"title":"","date":"2019-04-04T00:15:17.165Z","updated":"2019-04-04T00:15:17.165Z","comments":true,"path":"lib/jquery_lazyload/jquery.lazyload.js","permalink":"https://www.xjt5213.club/lib/jquery_lazyload/jquery.lazyload.js","excerpt":"","text":"/*! * Lazy Load - jQuery plugin for lazy loading images * * Copyright (c) 2007-2015 Mika Tuupola * * Licensed under the MIT license: * http://www.opensource.org/licenses/mit-license.php * * Project home: * http://www.appelsiini.net/projects/lazyload * * Version: 1.9.7 * */ (function($, window, document, undefined) { var $window = $(window); $.fn.lazyload = function(options) { var elements = this; var $container; var settings = { threshold : 0, failure_limit : 0, event : \"scroll\", effect : \"show\", container : window, data_attribute : \"original\", skip_invisible : false, appear : null, load : null, placeholder : \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" }; function update() { var counter = 0; elements.each(function() { var $this = $(this); if (settings.skip_invisible && !$this.is(\":visible\")) { return; } if ($.abovethetop(this, settings) || $.leftofbegin(this, settings)) { /* Nothing. */ } else if (!$.belowthefold(this, settings) && !$.rightoffold(this, settings)) { $this.trigger(\"appear\"); /* if we found an image we'll load, reset the counter */ counter = 0; } else { if (++counter > settings.failure_limit) { return false; } } }); } if(options) { /* Maintain BC for a couple of versions. */ if (undefined !== options.failurelimit) { options.failure_limit = options.failurelimit; delete options.failurelimit; } if (undefined !== options.effectspeed) { options.effect_speed = options.effectspeed; delete options.effectspeed; } $.extend(settings, options); } /* Cache container as jQuery as object. */ $container = (settings.container === undefined || settings.container === window) ? $window : $(settings.container); /* Fire one scroll event per scroll. Not one scroll event per image. */ if (0 === settings.event.indexOf(\"scroll\")) { $container.bind(settings.event, function() { return update(); }); } this.each(function() { var self = this; var $self = $(self); self.loaded = false; /* If no src attribute given use data:uri. */ if ($self.attr(\"src\") === undefined || $self.attr(\"src\") === false) { if ($self.is(\"img\")) { $self.attr(\"src\", settings.placeholder); } } /* When appear is triggered load original image. */ $self.one(\"appear\", function() { if (!this.loaded) { if (settings.appear) { var elements_left = elements.length; settings.appear.call(self, elements_left, settings); } $(\"\") .bind(\"load\", function() { var original = $self.attr(\"data-\" + settings.data_attribute); $self.hide(); if ($self.is(\"img\")) { $self.attr(\"src\", original); } else { $self.css(\"background-image\", \"url('\" + original + \"')\"); } $self[settings.effect](settings.effect_speed); self.loaded = true; /* Remove image from array so it is not looped next time. */ var temp = $.grep(elements, function(element) { return !element.loaded; }); elements = $(temp); if (settings.load) { var elements_left = elements.length; settings.load.call(self, elements_left, settings); } }) .attr(\"src\", $self.attr(\"data-\" + settings.data_attribute)); } }); /* When wanted event is triggered load original image */ /* by triggering appear. */ if (0 !== settings.event.indexOf(\"scroll\")) { $self.bind(settings.event, function() { if (!self.loaded) { $self.trigger(\"appear\"); } }); } }); /* Check if something appears when window is resized. */ $window.bind(\"resize\", function() { update(); }); /* With IOS5 force loading images when navigating with back button. */ /* Non optimal workaround. */ if ((/(?:iphone|ipod|ipad).*os 5/gi).test(navigator.appVersion)) { $window.bind(\"pageshow\", function(event) { if (event.originalEvent && event.originalEvent.persisted) { elements.each(function() { $(this).trigger(\"appear\"); }); } }); } /* Force initial check if images should appear. */ $(document).ready(function() { update(); }); return this; }; /* Convenience methods in jQuery namespace. */ /* Use as $.belowthefold(element, {threshold : 100, container : window}) */ $.belowthefold = function(element, settings) { var fold; if (settings.container === undefined || settings.container === window) { fold = (window.innerHeight ? window.innerHeight : $window.height()) + $window.scrollTop(); } else { fold = $(settings.container).offset().top + $(settings.container).height(); } return fold = $(element).offset().left + settings.threshold + $(element).width(); }; $.inviewport = function(element, settings) { return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) && !$.belowthefold(element, settings) && !$.abovethetop(element, settings); }; /* Custom selectors for your convenience. */ /* Use as $(\"img:below-the-fold\").something() or */ /* $(\"img\").filter(\":below-the-fold\").something() which is faster */ $.extend($.expr[\":\"], { \"below-the-fold\" : function(a) { return $.belowthefold(a, {threshold : 0}); }, \"above-the-top\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-screen\": function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-screen\" : function(a) { return !$.rightoffold(a, {threshold : 0}); }, \"in-viewport\" : function(a) { return $.inviewport(a, {threshold : 0}); }, /* Maintain BC for couple of versions. */ \"above-the-fold\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-fold\" : function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-fold\" : function(a) { return !$.rightoffold(a, {threshold : 0}); } }); })(jQuery, window, document);"}],"posts":[{"title":"谈谈css hack","slug":"谈谈css hack","date":"2019-07-27T16:00:00.000Z","updated":"2019-07-28T03:06:05.779Z","comments":true,"path":"2019/07/28/谈谈css hack/","link":"","permalink":"https://www.xjt5213.club/2019/07/28/谈谈css hack/","excerpt":"","text":"什么是CSS Hack??由于不同厂商的浏览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! CSS Hack的原理？？由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。 CSS Hack分类CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 属性前缀法(即类内部Hack)：例如 IE6能识别下划线”“和星号” “，IE7能识别星号” “，但不能识别下划线”“，IE6~IE10都认识”\\9”，但firefox前述三个都不能认识。 选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者*:first-child+html .class{}。 IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 CSS hack书写顺序，一般是将适用范围广、被识别能力强的CSS定义在前面。 CSS Hack方式一：条件注释法这种方式是ie浏览器专有的hack方式，微软官方推荐使用的hack方式，使用如下： 123456789101112131415161718192021222324只在IE下生效&lt;!--[if IE]&gt;这段文字只在IE浏览器显示&lt;![endif]--&gt;只在IE6下生效&lt;!--[if IE 6]&gt;这段文字只在IE6浏览器显示&lt;![endif]--&gt;只在IE6以上版本生效&lt;!--[if gte IE 6]&gt;这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt;只在IE8上不生效&lt;!--[if ! IE 8]&gt;这段文字在非IE8浏览器显示&lt;![endif]--&gt;非IE浏览器生效&lt;!--[if !IE]&gt;这段文字只在非IE浏览器显示&lt;![endif]--&gt; CSS Hack方式二：类内属性前缀法属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。 IE浏览器个版本CSS Hack对照表 说明：在标准模式中 “-″减号是IE6专有的hack “\\9″ IE6/IE7/IE8/IE9/IE10都生效 “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;script type=\"text/javascript\"&gt; //alert(document.compatMode);&lt;/script&gt;&lt;style type=\"text/css\"&gt;body:nth-of-type(1) .iehack&#123; color: #F00;/* 对Windows IE9/Firefox 7+/Opera 10+/所有Chrome/Safari的CSS hack ，选择器也适用几乎全部Mobile/Linux/Mac browser*/&#125;.demo1,.demo2,.demo3,.demo4&#123; width:100px; height:100px;&#125;.hack&#123;/*demo1 *//*demo1 注意顺序，否则IE6/7下可能无法正确显示，导致结果显示为白色背景*/ background-color:red; /* All browsers */ background-color:blue !important;/* All browsers but IE6 */ *background-color:black; /* IE6, IE7 */ +background-color:yellow;/* IE6, IE7*/ background-color:gray\\9; /* IE6, IE7, IE8, IE9, IE10 */ background-color:purple\\0; /* IE8, IE9, IE10 */ background-color:orange\\9\\0;/*IE9, IE10*/ _background-color:green; /* Only works in IE6 */ *+background-color:pink; /* WARNING: Only works in IE7 ? Is it right? */&#125; /*可以通过javascript检测IE10，然后给IE10的&lt;html&gt;标签加上class=”ie10″ 这个类 */.ie10 #hack&#123; color:red; /* Only works in IE10 */&#125; /*demo2*/.iehack&#123;/*该demo实例是用于区分标准模式下ie6~ie9和Firefox/Chrome的hack，注意顺序IE6显示为：绿色，IE7显示为：黑色，IE8显示为：红色，IE9显示为：蓝色，Firefox/Chrome显示为：橘色，（本例IE10效果同IE9,Opera最新版效果同IE8）*/ background-color:orange; /* all - for Firefox/Chrome */ background-color:red\\0; /* ie 8/9/10/Opera - for ie8/ie10/Opera */ background-color:blue\\9\\0; /* ie 9/10 - for ie9/10 */ *background-color:black; /* ie 6/7 - for ie7 */ _background-color:green; /* ie 6 - for ie6 */&#125; /*demo3实例是用于区分标准模式下ie6~ie9和Firefox/Chrome的hack，注意顺序IE6显示为：红色，IE7显示为：蓝色，IE8显示为：绿色，IE9显示为：粉色，Firefox/Chrome显示为：橘色，（本例IE10效果同IE9，Opera最新版效果也同IE9为粉色）*/.element &#123; background-color:orange; /* all IE/FF/CH/OP*/&#125;.element &#123; *background-color: blue; /* IE6+7, doesn't work in IE8/9 as IE7 */&#125;.element &#123; _background-color: red; /* IE6 */&#125;.element &#123; background-color: green\\0; /* IE8+9+10 */&#125;:root .element &#123; background-color:pink\\0; &#125; /* IE9+10 */ /*demo4*//*该实例是用于区分标准模式下ie6~ie10和Opera/Firefox/Chrome的hack，本例特别要注意顺序IE6显示为：橘色，IE7显示为：粉色，IE8显示为：黄色，IE9显示为：紫色，IE10显示为：绿色，Firefox显示为：蓝色，Opera显示为：黑色，Safari/Chrome显示为：灰色，*/.hacktest&#123; background-color:blue; /* 都识别，此处针对firefox */ background-color:red\\9; /*all ie*/ background-color:yellow\\0; /*for IE8/IE9/10 最新版opera也认识*/ +background-color:pink; /*for ie6/7*/ _background-color:orange; /*for ie6*/&#125; @media screen and (min-width:0)&#123; .hacktest &#123;background-color:black\\0;&#125; /*opera*/&#125; @media screen and (min-width:0) &#123; .hacktest &#123; background-color:purple\\9; &#125;/* for IE9/IE10 PS:国外有些习惯常写作\\0，根本没考虑Opera也认识\\0的实际 */&#125;@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123; .hacktest &#123; background-color:green; &#125; /* for IE10+ 此写法可以适配到高对比度和默认模式，故可覆盖所有ie10的模式 */&#125;@media screen and (-webkit-min-device-pixel-ratio:0)&#123; .hacktest &#123;background-color:gray;&#125; &#125; /*for Chrome/Safari*/ /* #963棕色 :root is for IE9/IE10, 优先级高于@media, 慎用！如果二者合用，必要时在@media样式加入 !important 才能区分IE9和IE10 *//*:root .hacktest &#123; background-color:#963\\9; &#125; */&lt;/style&gt; CSS Hack方式三：选择器前缀法选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。 目前最常见的是 123456789*html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\\9&#123;...&#125;只对IE6/7生效@media \\0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效@media \\0screen\\,screen\\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效@media screen\\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (min-width:0\\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效等等 css3选择器结合JavaScript的Hack我们用ie10进行举例 由于IE10用户代理字符串（UserAgent）为：Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)，所以我们可以使用javascript将此属性添加到文档标签中，再运用CSS3基本选择器匹配。 123var htmlObj = document.documentElement;htmlObj.setAttribute('data-useragent',navigator.userAgent);htmlObj.setAttribute('data-platform', navigator.platform ); 123html[data-useragent*='MSIE 10.0'] #id &#123; color: #F00;&#125; CSS Hack利弊一般情况下，我们尽量避免使用CSS hack，但是有些情况为了顾及用户体验实现向下兼容，不得已才使用hack。比如由于IE8及以下版本不支持CSS3,而我们的项目页面使用了大量CSS3新属性在IE9/Firefox/Chrome下正常渲染，这种情况下如果不使用css3pie或htc或条件注释等方法时,可能就得让IE8-的专属hack出马了。使用hack虽然对页面表现的一致性有好处，但过多的滥用会造成html文档混乱不堪，增加管理和维护的负担。相信只要大家一起努力，少用、慎用hack，未来一定会促使浏览器厂商的标准越来越趋于统一，顺利过渡到标准浏览器的主流时代。抛弃那些陈旧的IE hack，必将减轻我们编码的复杂度，少做无用功。 最后补上一张引自国外某大牛总结的CSS hack表，这时一张6年前的旧知识汇总表了，放在这里仅供需要时候方便参考。 转载自CSDN freshlover的博客专栏《史上最全CSS Hack方式一览》感兴趣的朋友可以去看看。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"浅谈JavaScript中原型链，prototype，__proto__的关系","slug":"浅谈JavaScript中原型链，prototype和__proto__的关系","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T09:10:11.765Z","comments":true,"path":"2019/07/27/浅谈JavaScript中原型链，prototype和__proto__的关系/","link":"","permalink":"https://www.xjt5213.club/2019/07/27/浅谈JavaScript中原型链，prototype和__proto__的关系/","excerpt":"","text":"proto和prototype __proto__ 引用《JavaScript权威指南》的一段描述 Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype. 翻译出来就是每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法。好啦，既然有这么一个原型对象，那么对象怎么和它对应的？ 对象proto属性的值就是它所对应的的原型对象 看一段代码 12345var one = &#123;x: 1&#125;;var two = new Object();one.__proto__ === Object.prototype // truetwo.__proto__ === Object.prototype // trueone.toString === one.__proto__.toString // true 上边代码应该已经足够清除地解释了什么是__proto__,好吧，显然还不够，或者说带来了新的问题？Object.prototype是什么？凭什么说one和two的原型就是Object.prototype prototype 首先来说说prototype属性，不想每个对象都有__proto__属性来标志自己所继承的原型，只有函数才有prototype属性,为什么只有函数才具有prototype属性呢？ES规范就是这么定的。 开玩笑了，其实函数在JS中真的很特殊，是所谓的一等公民。JS不像其它面向对象的语言，它没有类（class，ES6引进了这个关键字，但更多是语法糖）的概念。JS通过函数来模拟类。 当你创建一个函数时，js会为这个函数自动添加prototype属性，值是一个有constructor属性的对象，不是空对象，而一旦你把这个函数当做构造函数（constructor）来调用(即通过new关键字调用)，那么js就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法（实例通过设置自己的__proto__指向构造函数的prototype来实现这种继承）。 小结 虽然对不熟悉的人来说还有点绕，但JS正是通过__proto__和prototype的合作实现了原型链，以及对象的继承。 构造函数，通过prototype来存储要共享的属性和方法，也可以设置prototype指向现存的对象来继承该对象。 对象的__proto__指向自己构造函数的prototype。obj.__proto__.__proto__...的原型链由此产生，包括我们的操作符instanceof正是通过探测obj.__proto__.__proto__... === Constructor.prototype来验证obj是否是Constructor的实例。 回到开头的代码，two = new Object()中Object是构造函数，所以two.__proto__就是Object.prototype。至于one，ES规范定义对象字面量的原型就是Object.prototype。 更深一步的探讨我们知道JS是单继承的，Object.prototype是原型链的顶端，所有对象从它继承了包括toString等等方法和属性。 Object本身是构造函数，继承了Function.prototype;Function也是对象，继承了Object.prototype。这里就有一个鸡和蛋的问题： 12Object instanceof Function // trueFunction instanceof Object // true 具体到JS，ES规范是怎么说的？ Function本身就是函数，Function.__proto__是标准的内置对象Function.prototype。 Function.prototype.__proto__是标准的内置对象Object.prototype。 今天就先写到这儿，改天接写。。。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"浅谈JavaScript中的闭包","slug":"浅谈JavaScript中的闭包","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T10:11:02.559Z","comments":true,"path":"2019/07/27/浅谈JavaScript中的闭包/","link":"","permalink":"https://www.xjt5213.club/2019/07/27/浅谈JavaScript中的闭包/","excerpt":"","text":"这里引用MDN的说法 闭包是函数和声明该函数的词法环境的组合。 创建一个闭包最常见的方式是在一个函数内部创建另一个函数，下面写一个例子 1234567function f1()&#123; var a = 0; function closure()&#123; console.log(++a); &#125; return closure;&#125; 上面例子中，f1 内部的匿名函数以及它能够访问到的外部函数的变量 a 合在一起，就形成了一个闭包。使用 return 将闭包返回的目的是让它可以被外部访问。下面看看它怎么使用： 1234var f2 = f1(); // 执行外部函数，返回闭包f2(); // 2f2(); // 3f2(); // 4 第一句执行函数 f1() 后，闭包被返回并赋值给了一个全局变量 f2，以后每次调用 f2()，变量 a 的值就会加 1。通常函数执行完毕后，其作用域链和活动对象都会被销毁，为什么这里 a 并没有被销毁并且每次执行 f2() 还会被递增？原因是闭包有权访问外部函数的变量，进一步说，闭包的作用域链会引用外部函数的活动对象，所以f2() 在执行时，其作用域链实际上是： 自身的活动对象 f1()的活动对象 全局变量对象 所以 f1() 执行完后，其执行环境的作用域链会被销毁，但活动对象仍然会留在内存中，因为闭包作用域链在引用这个活动对象（说白了就是闭包还需要使用外层函数的变量，不允许它们被销毁），直到闭包被销毁后，f1() 的活动对象才会被销毁。 上面例子中，是将返回的闭包赋值给了一个全局变量 f2，var f2 = f1();，f2 是不会被销毁的，每次执行完 f2()，闭包的作用域链不会被销毁，所以就会出现每次执行 f2()，a 递增。 但是，换一种闭包的调用方式，情况会不同： 12f1()(); //2f1()(); //2 因为没有把闭包赋值给一个全局变量，闭包执行完后，其执行域链与活动对象都销毁了。 闭包的作用1. 创建用于访问私有变量的公有方法其实，构造函数中定义的实例方法就是闭包： 12345678910function Person()&#123; var name = 'Leon'; function sayHi() &#123; alert('Hi!'); &#125; this.publicMethod = function() &#123; alert(name); return sayHi(); &#125;&#125; 构造函数 Person 中定义实例方法publicMethod()就是一个闭包，它可以访问外部函数的变量 name和 函数 sayHi()，为什么要这么做呢？因为我们想在构造函数中定义一些私有变量，让外部不能直接访问，只能通过定义好的公有方法访问，从而达到保护变量，收敛外部权限的目的。 而在普通函数中，把闭包 return 出去供外部使用，其实目的也就是：让函数内部的变量始终保持在内存中，同时保护这些变量，让它们不能被直接访问。 1234567891011function person()&#123; var name = 'Leon'; function sayHi() &#123; alert('Hi!'); &#125; function publicMethod() &#123; alert(name); return sayHi(); &#125; return publicMethod;&#125; 2. 闭包用于创建单例所谓单例：就是只有一个实例的对象，单例模式的好处在于： 保证一个类只有一个实例，避免了一个在全局范围内使用的实例频繁创建与销毁。 比如网页中的弹窗，点击 a 按钮弹出，点击 b 按钮隐藏，如果弹窗每一次弹出都需要新建一个对象，将会造成性能的浪费，更好的办法就是只实例化一个对象，一直使用。 划分了命名空间，避免了与全局命名空间的冲突。 比如在一个单例中可以定义很多方法，通过单例.方法来使用，避免了在全局环境中定义函数，造成函数名冲突。 下面逐步介绍一下单例的创建方式，后两种方式将用到闭包 1. 对象字面量创建单例12345678910var singleton = &#123; attr1: 1, attr2: 2, method: function () &#123; return this.attr1 + this.attr2; &#125;&#125;var s1 = singleton;var s2 = singleton;console.log(s1 == s2) // true 上面用字面量形式创建了一个单例，可以看到 s1 和 s2 是等同的。这种方式的问题在于外部可以直接访问单例的内部变量并加以修改，如果想让单例拥有私有变量，就需要使用模块模式，模块模式就是用了闭包。 2. 模块模式JS 中的模块模式的作用是：为单例添加私有变量和公有方法。它使用立即执行函数和闭包来达到目的。 12345678910111213141516171819var singleton = (function()&#123; // 创建私有变量 var privateNum = 1; // 创建私有函数 function privateFunc()&#123; console.log(++privateNum); &#125; // 返回一个对象包含公有方法 return &#123; publicMethod: function()&#123; console.log(privateNum) return privateFunc() &#125; &#125;;&#125;)();singleton.publicMethod();// 1// 2 这里首先定义了一个立即执行函数，它返回一个对象，该对象中有一个闭包 publicMethod()， 它可以访问外部函数的私有变量。从而这个被返回的对象就成为了单例的公共接口，外部可以通过它的公有方法访问私有变量而无权直接修改。总结一下就是两点： 立即执行函数可以创建一个块级作用域， 避免在全局环境中添加变量。 闭包可以访问外层函数中的变量。 3. 构造函数+闭包上面提到的对象字面是用来创建单例的方法之一，既然单例只能被实例化一次，不难想到，在使用构造函数新建实例时，先判断实例是否已被新建，未被新建则新建实例，否则直接返回已被新建的实例。 12345678910111213141516171819var Singleton = function(name)&#123; this.name = name;&#125;;// 获取实例对象var getInstance = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)();var a = getInstance('1');console.log(a); // &#123;name: \"1\"&#125;var b = getInstance('2');console.log(b); // &#123;name: \"1\"&#125; 这里将构造函数和实例化过程进行了分离， getInstance()中存在一个闭包，它可以访问到外部变量 instance，第一次 instance = null，则通过 new Singleton(name)新建实例，并将这个实例保存在instance 中，之后再想新建实例，因为闭包访问到的instance已经有值了，就会直接返回之前实例化的对象。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"浅谈圣杯布局和双飞翼布局","slug":"浅谈圣杯布局和双飞翼布局","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T07:25:44.038Z","comments":true,"path":"2019/07/27/浅谈圣杯布局和双飞翼布局/","link":"","permalink":"https://www.xjt5213.club/2019/07/27/浅谈圣杯布局和双飞翼布局/","excerpt":"","text":"最近面试碰到一个问题—圣杯布局和双飞翼布局，其实自己也不太明白，今天就来记录一下学习过程 首先圣杯布局和双飞翼布局，都属于三列布局的经典布局 圣杯布局是外国人发明的 双飞翼布局是圣杯布局的优化版，由淘宝UED提出 他们的效果很类似，但是实现方法不同 以下是效果图 实现步骤： 1. 先把HTML结构写好123&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 2. 写一下上边的基本样式12345678 .header &#123; height: 40px; background: lightblue; &#125;.footer &#123; height: 100px; background: lightcoral; &#125; 3. 布局正式开始，现在往main元素里面加东西12345&lt;div class=\"main\"&gt; &lt;div class=\"center\"&gt;中间自适应&lt;/div&gt; &lt;div class=\"left\"&gt;左列定宽&lt;/div&gt; &lt;div class=\"right\"&gt;右列定宽&lt;/div&gt;&lt;/div&gt; 4. 定义一下center，left，right的基本样式123456789101112131415.center &#123; width: 100%; height: 500px; background: lightgray; &#125; .left &#123; width: 200px; height: 500px; background: lightpink; &#125; .right &#123; width: 300px; height: 500px; background: lightgreen; &#125; 注意到这一步，请在浏览器查看效果，出现这种效果的原因是因为，center，left，right处于文档流中，而块元素又独占一行 5. 现在，我们让center，left，right浮动起来123.center,.left,.right&#123; float:left;&#125; 现在 center、left、right 都浮动起来了，但是因为 center 的 width 为 100%，center 仍然会占满一行，所以 left 和 right 只能浮在 center 下面。 注意：我们没有给 main 设置高度，它的高度本来是由里边的子元素（center、left、right） 撑起来的。但是现在子元素都设置了浮动，脱离了文档流，所以 main 的高度又变成了0，所以 footer 元素会往上跑，被浮动元素盖住。 6. 清除浮动，让footer回到原来的位置123.main&#123; overflow: hidden; &#125; 清除浮动的方法这里就不再赘述，我之前的博文中有一篇是专门讲解清除浮动的，感兴趣的可以去看看 7. 给left和right添加以下代码，让left， center，right在同一行显示123456.left&#123; margin-left:-100%;&#125;.right&#123; margin-left:-300px;&#125; 我们可以看到，center上的“中间自适应”几个字不见了，很显然是因为left和right覆盖在了center上面，如果center有更多内容，依然将无法显示。 为了解决上述问题，圣杯布局和双飞翼布局采用了不同的做法。 首先是圣杯布局 给三列的父元素main，加上margin-left和margin-right,将三列挤到中间来，这样左边和右边就会预留出位置 1234.main&#123; padding-left: 200px; padding-right: 300px;&#125; 给left和right设置相对位置，将他们移动到相应的位置 12345678.left&#123; position:relative; left:-200px;&#125;.right&#123; position:relative; right:-300px;&#125; 到这里，圣杯布局就完成了，可以在浏览器试试效果 现在，返回到第7步，利用双飞翼布局来解决 双飞翼布局 给center加一个子元素inner 123&lt;div class=\"center\"&gt; &lt;div class=\"inner\"&gt;中间自适应&lt;/div&gt;&lt;/div&gt; 给inner设置margin-left和margin-right，将inner挤到中间显示 1234.inner&#123; margin-left:200px; margin-right:300px;&#125; 到这里，双飞翼布局就完成了，可以在浏览器看看效果","categories":[],"tags":[{"name":"学习笔记 教程","slug":"学习笔记-教程","permalink":"https://www.xjt5213.club/tags/学习笔记-教程/"}]},{"title":"vue组件间传值","slug":"vue实现组件间传值","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T03:44:09.470Z","comments":true,"path":"2019/07/27/vue实现组件间传值/","link":"","permalink":"https://www.xjt5213.club/2019/07/27/vue实现组件间传值/","excerpt":"","text":"说到组件吗传值，无非就是父组件传子组件，子组件传父组件，兄弟组件之间传值，先来讲讲父组件传子组件的情况。先看看下面的使用场景:父组件点击传值给子组件 在这里触发handleClick点击事件，额外声明一个clickData。点击按钮将inpMessage的值赋值给clickData，再传给子组件 父组件App.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inpMessage&quot;&gt; &lt;button @click=&quot;handleClick&quot;&gt;点击传给子组件&lt;/button&gt; &lt;children :message=&quot;clickData&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children from &apos;./components/children&apos;export default &#123; name: &apos;App&apos;, components:&#123; children &#125;, data:function () &#123; return &#123; inpMessage:&apos;&apos;, clickData:&apos;&apos; &#125; &#125;, methods:&#123; handleClick()&#123; this.clickData = this.inpMessage &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 子组件：children.vue 1234567891011121314&lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;message&quot;&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:[&apos;message&apos;], name: &quot;children&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 上面是父组件传值给子组件的过程，最重要的点是props接收，上面是点击事件传值，还有一种场景是动态传值，实时更新父组件的值，自组件动态更新，这里就要用到watch了，附上自组件代码 子组件：children.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;input type=\"text\" v-model=\"childrenMessage\"&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:['message'], name: \"children\", data:function () &#123; return &#123; childrenMessage:'' &#125; &#125;, created() &#123; this.childrenMessage = this.message &#125;, //这里用watch方法来监听父组件传过来的值，实现动态更新 watch:&#123; message(val)&#123; //message即为父组件的值，val参数为值 this.childrenMessage = val //将父组件的值赋值给childrenMessage 子组件的值 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 子组件传父组件，核心–$emit，这里附上完整父子传值的代码,vue是不允许子组件向父组件传值去改变父组件的值的，但是我们可以通过自定义事件的形式去改变值，例如点击事件，再通过$emit来传递，代码注释中有介绍。 父组件：App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inpMessage&quot;&gt; &lt;button @click=&quot;handleClick&quot;&gt;点击传给子组件&lt;/button&gt;&lt;!-- @messageData为子组件声明传递过来的值，函数，getData为函数，val参数是传递过来的值--&gt; &lt;children :message=&quot;clickData&quot; @messageData=&quot;getData&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children from &apos;./components/children&apos;export default &#123; name: &apos;App&apos;, components:&#123; children &#125;, data:function () &#123; return &#123; inpMessage:&apos;&apos;, clickData:&apos;&apos; &#125; &#125;, methods:&#123; handleClick()&#123; this.clickData = this.inpMessage &#125;, //接收子组件传递的值，val参数是传递过来的值 ，给inpMessage 赋值，子组件改变父组件的值 getData(val)&#123; this.inpMessage = val &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 子组件：children.vue 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;childrenMessage&quot;&gt; &lt;button @click=&quot;childClick&quot;&gt;传值给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:[&apos;message&apos;], name: &quot;children&quot;, data:function () &#123; return &#123; childrenMessage:&apos;&apos; &#125; &#125;, created() &#123; this.childrenMessage = this.message &#125;, //这里用watch方法来监听父组件传过来的值，实现动态更新 watch:&#123; message(val)&#123; //message即为父组件的值，val参数为值 this.childrenMessage = val //将父组件的值赋值给childrenMessage 子组件的值 &#125; &#125;, methods:&#123; //点击传值给父组件，通过$emit传递，第一个参数messageData相当于传播的媒介，this.childrenMessage为需要传递的值，后面也可以传递多个参数 childClick()&#123; this.$emit(&apos;messageData&apos;,this.childrenMessage) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 以上就是父子组件之前传值的一个过程，如有不明白的欢迎在下方留言，如有错误也欢迎指出，感谢！！！","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"vuex使用方式","slug":"vuex使用方式","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T12:43:07.847Z","comments":true,"path":"2019/07/26/vuex使用方式/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/vuex使用方式/","excerpt":"","text":"1 这段时间一直在用vue写项目，突然在网上看到一个新东西–vuex，和vue长得很像，于是就想把它弄懂，感觉在日后的开发中也有用先说一下vuex到底是什么??? 12&gt; vuex 是一个专门为vue.js应用程序开发的状态管理模式。&gt; 这个状态我们可以理解为在data中的属性，需要共享给其他组件中使用的部分，也就是说，我们需要共享的data，使用vuex来进行统一集中式的管理。 在vuex中，有默认的五种基本的对象： state：存储状态（变量） getters:对数据获取之前再次编译，可以理解为state的计算属性，我们在组件中使用$store.getters.fun() mutations:修改状态，并且是同步的，在组件中使用$store.commit(‘’,params),这个和我们组件中的自定义事件类似 actions：异步操作，在组件中使用的是$store.disapth(‘’) modules:store的子模块，为了开发大型项目，方便状态管理而使用的，这里我们就不解释了，用法和上边一样 下面，我们就正式开始，一步一步的使用vuex1 首先创建一个vue-cli项目1vue init webpack app 2 创建完成之后，我们进入文件夹下，并运行项目12cd appnpm run dev 3 接下来我们在src目录下新建一个文件夹vuex,同时在文件夹下创建一个store.js的文件目录层级类似下图 4 目前我们还没有引入vuex，先下载vuex,并且引入它 5 安装成功之后，在store.js中引入Vuex123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;export default new Vuex.Store(&#123; state&#125;) 6 在main.js中引入store1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'import store from './vuex/store' //引入storeVue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, //在实例上挂载store components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 然后我们就可以在任意一个组件中使用我们定义的count属性了 我们在helloworld.vue中使用一下 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;,&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 然后我们就可以在浏览器看到效果了 7 到这一步，vuex已经成功一小半了，回想一下，我们只需要安装使用vuex，在store.js中定义state对象，并且暴露出去，在main.js中使用我们的store.js(这里是为了防止在各个组件中引用，因为main.js中我们有new Vue({})实例)8 现在我们已经使用了state，接下来我们该如何操作这个值呢？没错，使用mutations和actions我们继续操作store.js文件，我们在store.js文件中定义mutations对象，该对象有两个方法，mutations里面的参数：第一个默认为state，第二个为自定义参数 我们在mutations中定义两个方法：增加和减少，并且设置一个参数为n,默认值为0，然后在Vuex.Store中使用它 1234567891011121314151617181920212223//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;//定义一个mutations对象const mutations = &#123; mutationsAddCount(state,n = 0)&#123; return state.count +=n; &#125;, mutationsReduceCount(state,n = 0)&#123; return state.count -=n; &#125;&#125;export default new Vuex.Store(&#123; state, mutations //使用mutations对象&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940//helloworld.vue&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;button @click=\"addCount(20)\"&gt;add&lt;/button&gt; &lt;button @click=\"reduceCount(30)\"&gt;reduce&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', methods:&#123; addCount(n)&#123; this.$store.commit('mutationsAddCount',n) &#125;, reduceCount(n)&#123; this.$store.commit(\"mutationsReduceCount\",n) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 来看一下浏览器效果如何 我们可以看到，每当我们出发事件时，都可以在浏览器中看到我们触发的mutations方法。 9 创建actions对象创建actions对象并使用 这里actions对象包含两个方法，两个方法中使用了不同的两个参数：一个是context,它是一个和store对象具有相同对象属性的参数，在第二个函数中，我直接使用了这个对象的commit方法，凭大家喜好就行 12345678910111213141516171819202122232425262728293031323334//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;const mutations = &#123; mutationsAddCount(state,n = 0)&#123; return state.count +=n; &#125;, mutationsReduceCount(state,n = 0)&#123; return state.count -=n; &#125;&#125;const actions = &#123; actionsAddCount(context,n = 0)&#123; return context.commit('mutationsAddCount',n) // return state.count +=n &#125;, actionsReduceCount(&#123;commit&#125;,n = 0)&#123; return commit('mutationsReduceCount',n) // return state.count -=n &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//helloworld.vue&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addCount(20)&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;reduceCount(30)&quot;&gt;reduce&lt;/button&gt; &lt;button @click=&quot;syncAddCount(10)&quot;&gt;异步增加&lt;/button&gt; &lt;button @click=&quot;syncReduceCount(20)&quot;&gt;异步减少&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;, methods:&#123; addCount(n)&#123; this.$store.commit(&apos;mutationsAddCount&apos;,n) &#125;, reduceCount(n)&#123; this.$store.commit(&quot;mutationsReduceCount&quot;,n) &#125;, syncAddCount(n)&#123; this.$store.dispatch(&apos;actionsAddCount&apos;,n) &#125;, syncReduceCount(n)&#123; this.$store.dispatch(&apos;actionsReduceCount&apos;,n) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 在helloworld.vue中，在methods中，增加两个方法，使用dispath()来触发，最后的效果就是上图所示。 10 最后就是getters我们一般使用getters来获取我们的state,因为它算是state的一个计算属性 12345678910111213141516171819202122232425262728293031323334353637383940//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count:0&#125;const mutations = &#123; mutationsAddCount(state,n = 0)&#123; return state.count +=n; &#125;, mutationsReduceCount(state,n = 0)&#123; return state.count -=n; &#125;&#125;const actions = &#123; actionsAddCount(context,n = 0)&#123; return context.commit('mutationsAddCount',n) // return state.count +=n &#125;, actionsReduceCount(&#123;commit&#125;,n = 0)&#123; return commit('mutationsReduceCount',n) // return state.count -=n &#125;&#125;const getters = &#123; getterCount(state)&#123; return state.count +=10; &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//helloworld.vue&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h1&gt; &lt;button @click=\"addCount(20)\"&gt;add&lt;/button&gt; &lt;button @click=\"reduceCount(30)\"&gt;reduce&lt;/button&gt; &lt;button @click=\"syncAddCount(10)\"&gt;异步增加&lt;/button&gt; &lt;button @click=\"syncReduceCount(20)\"&gt;异步减少&lt;/button&gt;&lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', methods:&#123; addCount(n)&#123; this.$store.commit('mutationsAddCount',n) &#125;, reduceCount(n)&#123; this.$store.commit(\"mutationsReduceCount\",n) &#125;, syncAddCount(n)&#123; this.$store.dispatch('actionsAddCount',n) &#125;, syncReduceCount(n)&#123; this.$store.dispatch('actionsReduceCount',n) &#125; &#125;, computed:&#123; count() &#123; return this.$store.getters.getterCount &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; getter算是非常简单的了，到这里如果全都看懂了，vuex你已经没有压力了 但是vuex官方给了我们一个更加简单的方式来使用vuex，也就是{mapState, mapMutations, mapActions, mapGetters} 只要我们把上边的基础搞懂，这些都不在话下，只是方便我们书写罢了 就这么简单，这里我们用到了ES6的拓展运算符，如果部署下的同学建议去看看阮一峰的《ES6入门标准》这本书 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt;import &#123;mapState, mapMutations, mapActions, mapGetters&#125; from &apos;vuex&apos;export default &#123; name: &apos;HelloWorld&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, methods: &#123; ...mapMutations(&#123; handleAddClick: &apos;mutationsAddCount&apos;, handleReduceClick: &apos;mutationsReduceCount&apos; &#125;), ...mapActions(&#123; handleActionsAdd: &apos;actionsAddCount&apos;, handleActionsReduce: &apos;actionsReduceCount&apos; &#125;) // handleAddClick(n)&#123; // this.$store.commit(&apos;mutationsAddCount&apos;,n); // &#125;, // handleReduceClick(n)&#123; // this.$store.commit(&apos;mutationsReduceCount&apos;,n); // &#125;, // handleActionsAdd(n)&#123; // this.$store.dispatch(&apos;actionsAddCount&apos;,n) // &#125;, // handleActionsReduce(n)&#123; // this.$store.dispatch(&apos;actionsReduceCount&apos;,n) // &#125; &#125;, computed: &#123; count()&#123; return this.$store.getters.getterCount &#125; &#125;&#125;&lt;/script&gt; 同理，getters和 state也可以使用 mapState，mapGetters 最后，如果本文有什么错误的地方，欢迎在下方评论区指出，不胜感激！！！","categories":[],"tags":[{"name":"学习笔记，教程","slug":"学习笔记，教程","permalink":"https://www.xjt5213.club/tags/学习笔记，教程/"}]},{"title":"v-model是什么?怎么使用？vue中标签如何绑定事件","slug":"v-model使用及标签绑定事件","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T07:28:52.604Z","comments":true,"path":"2019/07/26/v-model使用及标签绑定事件/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/v-model使用及标签绑定事件/","excerpt":"","text":"引用官方文档的一段话 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 v-moidel在内部为不同的输入元素使用不同的属性并跑出不同的时间 text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" value=\"篮球\" id=\"basketball\" v-model=\"message\" checked&gt; &lt;label for=\"basketball\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" value=\"足球\" id=\"football\" v-model=\"message\"&gt; &lt;label for=\"football\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" value=\"羽毛球\" id=\"yumao\" v-model=\"message\"&gt; &lt;label for=\"yumao\"&gt;羽毛球&lt;/label&gt; &lt;div&gt;你的选择是：&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; $(function () &#123; new Vue(&#123; el:\"#app\", data:&#123; message:[] &#125; &#125;) &#125;)&lt;/script&gt; 所谓数据的双向绑定，指的就是我们在js中的vue实例中的data与其渲染的dom元素上的内容保持一致，两者无论谁被改变，另一方也会相应的更新为相同的数据。这是通过设置属性访问器实现的。 2. vue中标签如何绑定事件可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 1234&lt;div id=\"example-2\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"js事件冒泡及事件捕获","slug":"js事件冒泡及捕获","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-26T03:22:43.184Z","comments":true,"path":"2019/07/26/js事件冒泡及捕获/","link":"","permalink":"https://www.xjt5213.club/2019/07/26/js事件冒泡及捕获/","excerpt":"","text":"DOM事件流存在三个阶段：即事件捕获阶段、出于目标阶段、事件冒泡阶段事件捕获：通俗的理解就是，当鼠标点击或者触发DOM事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获的方式注册了对应事件的话，就会先触发父元素绑定的事件。 事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内向外进行事件传播。 无论是事件捕获还是事件冒泡，它们都有一个共同的行为：那就是事件传播。它就像是一根引线，只有通过引线，才能将绑定在引线上的鞭炮（事件监听器）引爆。 DOM标准事件流的触发先后顺序为先捕获再冒泡，即当触发DOM事件时，先进行事件捕获，捕获到事件源时候通过事件传播进行事件冒泡，不同的浏览器对此有着不同的实现，ie10及以下不支持事件捕获，所以就少了一个事件捕获阶段；IE11，Chrome，Firefox，Safari等浏览器则同时存在。 说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent。当然还有其它的事件绑定的方式这里不做介绍。 ​ addEventListener(event, listener, useCapture) ​ ·参数定义：event—（事件名称，如click，不带on） ​ listener—事件监听函数 ​ useCapture—*是否采用事件捕获进行事件捕捉，默认为false，即采用事件冒泡方式 ​ attachEvent(event,listener) ​ ·参数定义：event—（事件名称，如onclick，带on） ​ listener—事件监听函数。 attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了（微软还是挺识趣的，慢慢向标准靠拢）。 事件冒泡例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent&#123; width: 200px; height:200px; text-align: center; line-height: 3; background: green; &#125; #child&#123; width: 100px; height: 100px; margin: 0 auto; background: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"parent\"&gt; 父元素 &lt;div id=\"child\"&gt; 子元素 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); document.body.addEventListener('click',function () &#123; console.log(\"click-body\") &#125;,false) parent.addEventListener('click',function () &#123; console.log('click-parent') &#125;,false) child.addEventListener('click',function () &#123; console.log('click-child') &#125;,false)&lt;/script&gt; 通过addEventListener方法，采用事件冒泡方式给DOM元素注册事件，点击子元素会发生什么呢？如果你对事件冒泡有一定的了解的话，name你一定会知道上面代码的输出顺序，如下图所示： 事件触发顺序是由内到外的，这就是事件冒泡，虽然只点击子元素，但是它的父元素也会触发相应的事件，其实这是合理的，因为子元素在父元素里面，点击子元素也就相当于变相的点击了父元素，这样理解对吧？ 这里有同学可能要问了，如果点击子元素不想触发父元素的事件怎么办？肯定可以的，那就是停止事件传播—event.stopPropagation(); 修改例子1的代码，在子元素的事件监听函数中加入停止事件冒泡的操作，示例2. 1234child.addEventListener('click',function (e) &#123; console.log('click-child') e.stopPropagation() &#125;,false) 在改变上述代码之后，点击子元素，浏览器控制台将输出什么呢，如图： 由于手动停止了事件冒泡，所以点击子元素的时候就只触发了子元素的click方法，并没有触发父元素及body的，冒泡阶段也就停止了。 讲完了事件冒泡，接下来讲一下事件捕获，请看示例 修改例子1中的代码，给parent元素注册一个捕获事件 123456789101112var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); document.body.addEventListener('click',function () &#123; console.log(\"click-body\") &#125;,false) parent.addEventListener('click',function () &#123; console.log('click-parent') &#125;,true) child.addEventListener('click',function (e) &#123; console.log('click-child') &#125;,false) 看明白我说的那些，就知道上面的代码输出顺序了： 父元素通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，然后到了目标阶段，即事件源，之后进行事件传播，parent同时也用冒泡方式注册了click事件，所以这里会触发冒泡事件，最后到根节点。这就是整个事件流程。 上面介绍了事件冒泡、事件捕获、事件传播，下面讲一下如何通过以上三个知识点进行事件委托 委托在JQuery中已经得到了实现，即通过$(*selector*).on(*event,childSelector,data,function,map*)实现委托，一般用于动态生成的元素，当然JQuery也是通过原声的js去实现的，下面举一个简单的栗子，通过js实现通过parent元素给child元素注册click事件 1234567var parent = document.getElementById(\"parent\"); var child = document.getElementById('child'); parent.onclick = function (e) &#123; if (e.target.id == 'child')&#123; console.log('click-child'); &#125; &#125; 虽然没有直接只child元素注册click事件，可是点击child元素时却弹出了提示信息。 到这里是不是对js的事件机制有一定的了解了呢？感觉有帮助的话就看看下面的小黄脸，你懂得哦！ 如有错误，欢迎指正 如有问题，欢迎提问","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"Linux命令学习","slug":"linux常用命令","date":"2019-06-26T16:00:00.000Z","updated":"2019-06-27T05:59:20.802Z","comments":true,"path":"2019/06/27/linux常用命令/","link":"","permalink":"https://www.xjt5213.club/2019/06/27/linux常用命令/","excerpt":"","text":"话不多说直接上命令哈哈哈哈Linux常用命令 1. 目录操作命令 \\1. ls:显示当前目录下的文件（不包含隐藏文件） \\2. ls 目录名：显示指定目录下的文件 \\3. ls -l :列出文件的详细信息 \\4. ls -l 文件名：显示指定文件的详细信息 \\5. ls -a:显示当前目录下的所有文件（包含了隐藏文件） \\6. cd 绝对路径：进入到指定路径 \\7. cd ~ : 进入到当前用户的家目录 \\8. cd .. : 进入到上一级目录 \\9. cd / : 返回根目录 \\10. cd ./当前目录下的其他文件夹:进入当前目录下的其他目录 \\11. pwd : 显示当前所在的目录 \\12. mkdir 自定义目录名：例如-mkdir test 在当前目录下创建名为test的目录 \\13. mkdir -p 递归路径：例如mkdir -p test1/test2/test3 \\14. rmdir 目录名 ：删除目录（只能删除空目录） 2. 文件操作命令 \\1. touch: 创建空文件（文件不存在时）或者修改文件时间（文件存在时修改文件时间） \\2. rm 文件名：删除文件 \\3. rm -f 文件名：强制删除文件 \\4. rm -rf 目录名：强制删除目录和文件 \\5. cat 文件名：查看文件内容 \\6. cp 源文件 目标位置：复制文件到指定目录 \\7. cp -r 目录名 目标位置：复制目录到指定目录 \\8. mv 源文件 目标位置： 例如：mv /root/test /tmp/ 将/root/下的test文件移动到/tmp/目录下 mv /root/test /root/newtest 将/root/下的test文件改名为newtest 3. 查找命令 \\1. find 查找位置 -name 文件名： \\2. whereis 文件名：查找文件，同时列出文件路径 \\3. Which ：用于查找可执行命令，只能查找可执行文件， 例如which ls 4. 编辑命令 \\1. Vi 文件名：编辑文件 \\1. Ins 进入编辑模式 \\2. Esc 退出编辑模式，进入命令模式 \\3. \\2. vim 文件名：用法与vi类似 \\3. nano 文件名： \\4. 换源 Yum工具：换源路径： /etc/yum.repos.d/CentOS-Base.repo yum makecache：更新软件包缓存 Apt工具：换源路径： /etc/apt/sources.list Apt-get update :更新缓存","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"vue-router使用步骤","slug":"vue-router使用步骤详解","date":"2019-06-25T16:00:00.000Z","updated":"2019-07-26T05:59:43.816Z","comments":true,"path":"2019/06/26/vue-router使用步骤详解/","link":"","permalink":"https://www.xjt5213.club/2019/06/26/vue-router使用步骤详解/","excerpt":"","text":"最近在学习vue框架，一直对vue中的路由使用步骤不太明白，于是就写一篇关于vue-router的使用步骤吧 1. 安装vue-router（使用npm安装）1npm install vue-router --save 2. 在vue组件内配置router-link和router-view router-link:映射路由.就是创建a标签来定义路由导航的链接(用户通过点击实现跳转).通过to属性指定目标地址.默认渲染成带有正确链接的标签. router-view:就是在标签内渲染你路由匹配到的视图组件.router-view支持嵌套router-view,并且支持多个router-view分别渲染不同的component. 具体用法如下 12345678&lt;!--这里引用官方例子的写法--&gt;&lt;div id='app'&gt; &lt;p&gt; &lt;router-link to=\"/user/foo\"&gt;/user/foo&lt;/router-link&gt; &lt;router-link to=\"/user/bar\"&gt;/user/bar&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;PS:写在这里,即router-view里的内容是不会显示在页面上的!&lt;/router-view&gt;&lt;/div&gt; 3. 配置路由实例index.js1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from &apos;vue&apos; //第一步，引入必要的文件vue,加载全局组件时使用import Router from &apos;vue-router&apos; //第二步，引入vue-router//第三步. 加载路由组件import Main from &quot;../components/Main/Main&quot;;import aboutus from &quot;../components/aboutus/aboutus&quot;import like from &quot;../components/like/like&quot;import news from &quot;../components/news/news&quot;import reverse from &quot;../components/reverse/reverse&quot;//第四步，加载全局组件RouterVue.use(Router)//第五步，配置路由实例export default new Router(&#123; linkActiveClass:&apos;active&apos;, //为当前选中的router-link组件添加active routes: [ &#123; path: &apos;/&apos;, redirect:&quot;/Main&quot;, //设置重定向 component: Main &#125;, &#123; path: &apos;/Main&apos;, component: Main &#125;, &#123; path:&apos;/aboutus&apos;, component:aboutus &#125;, &#123; path:&apos;/like&apos;, component:like &#125;, &#123; path:&apos;/news&apos;, component:news &#125;, &#123; path:&apos;/reverse&apos;, component:reverse &#125; ]&#125;) 4. 在main.js中引入router.js并挂载到vue实例上1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router' //引入router.jsimport $ from 'jquery'import 'bootstrap'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, //挂载到vue实例，这个是简写，全称是router：router components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 5. 区分一下router，routes，route? router:一般指的就是路由实例.如$router. routes:指router路由实例的routes API.用来配置多个route路由对象. route:指的就是路由对象.例如;$route指的就是当前路由对象.","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"HTML/CSS基础总结（1）","slug":"htmlcss面试基础题（1）","date":"2019-06-19T16:00:00.000Z","updated":"2019-06-20T10:31:51.401Z","comments":true,"path":"2019/06/20/htmlcss面试基础题（1）/","link":"","permalink":"https://www.xjt5213.club/2019/06/20/htmlcss面试基础题（1）/","excerpt":"","text":"1.列出display的值，说明他们的作用。 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。 list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示，表格前后带有换行符。 inline-table 此元素会作为内联表格来显示，表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示 table-header-group 此元素会作为一个或多个行的分组来显示 table-footer-group 此元素会作为一个或多个行的分组来显示 table-row 此元素会作为一个表格行显示 table-column-group 此元素会作为一个或多个列的分组来显示 table-column 此元素会作为一个单元格列显示 table-cell 此元素会作为一个表格单元格显示 table-caption 此元素会作为一个表格标题显示 inherit 规定应该从父元素继承 display 属性的值。 2.position的值：relative和absolute的定位原点是？ absolute：绝对定位，定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点。 relative：相对定位，定位原点是元素本身所在的位置。 3.CSS3有哪些新特性？ 圆角border-radius:值通常有px、rem、em、%（基于元素的width和height表示）。 1，当为一个值时：表示所有的角都为这个值 2，当为两个值时，表示左上，右下角相等、右上、左下角相等 3，当为三个值时，第一个值为左上角，第二个值为左下、右上角，第三个值为右下角 4，当为多个值时，可以为所有的角都设置值，从左上角开始 5，当用/来表示时，/前面的为水平半径，/后的为垂直半径","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"清除浮动的几种方法","slug":"清除浮动的方法","date":"2019-04-12T06:43:45.000Z","updated":"2019-04-12T08:33:27.352Z","comments":true,"path":"2019/04/12/清除浮动的方法/","link":"","permalink":"https://www.xjt5213.club/2019/04/12/清除浮动的方法/","excerpt":"","text":"今天在班上分享几种清除浮动的方法，讲到一半突然忘了，贼尴尬，于是自己在网上找了几种解决办法来清除浮动 先看一段代码—-html 123456&lt;body&gt; &lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 再给一段css代码 1234567891011121314151617&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float:left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float:left; &#125; &lt;/style&gt; 上面代码中我分别给了两个子div一个float：left;于是他们就向左浮动，出现在一行了；看看下图效果 从中可以看到，当我给两个子div分别设置向左浮动之后，可以看看右下角的盒子模型，父div的高度变成了0，这是为什么呢？ 情况是这样的，当我们分别给两个子div设置float:left;之后，子就会脱离文档流，不在占有页面位置了，所以我们看到的高度为0了 那么我们应该怎样解决这种情况呢（在不删除float:left;的情况下）？？ 在网上找了几种解决办法： 1，利用clear:both;1，在父级下面增加一个空标签，设置css属性为clear:both;。看代码—css 1234567891011121314151617181920&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; + .myDiv03&#123; + clear: both; + &#125; &lt;/style&gt; html 1234567&lt;body&gt; &lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; + &lt;div class=\"myDiv03\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 最后看效果 可以看到加上上面代码之后，在看右下角的盒子模型，父级的高度变成了200px;也就是说生效了。 2，直接给父级具体的宽和高我们可以直接给父级一个具体的宽高，之前我们是没有给父级宽度和高度的，父级的宽度和高度是由子撑开的 ，下面我们给父级一个具体的宽度和高度 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 1234567891011121314151617181920&lt;style type=\"text/css\"&gt; .myDiv&#123; + width: 500px; + height: 300px; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 给了之后来看效果 给了具体的宽高之后，右下角的盒子模型里面父级的宽度和高度就是css代码里面我给的宽高了，所以这种方法也可行 3，利用伪元素：：after我们还可以利用伪元素::after来达到清除浮动的效果，直接上代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125;+ .myDiv::after&#123;+ content: \"\";+ width: 0;+ height: 0;+ visibility: hidden;+ display: block;+ &#125; &lt;/style&gt; 来看一下效果是什么样子的 利用伪元素::after之后也可以解决 ，原理是通过清除伪元素的浮动，达到撑起父元素高度的目的。注意到该伪元素的display类型为block,他是一个不可见的块级元素。其原理跟方法一类似。 4，利用overflow来清除浮动我们可以直接给父元素一个overflow:hidden;或者overflow:auto样式，来看看代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red;+ overflow: hidden; /*用overflow:auto;也行*/ &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 我们来看看效果 这个原理的话暂时还没弄明白，等后面弄明白了再来更新吧！！！ 5，给父级也添加float:left;属性也可以直接给父级一个float:left;样式属性 看代码 html 1234&lt;div class=\"myDiv\"&gt; &lt;div class=\"myDiv01\"&gt;&lt;/div&gt; &lt;div class=\"myDiv02\"&gt;&lt;/div&gt; &lt;/div&gt; css 12345678910111213141516171819&lt;style type=\"text/css\"&gt; .myDiv&#123; background-color: red; float: left; &#125; .myDiv01&#123; width: 200px; height: 200px; background-color: pink; float: left; &#125; .myDiv02&#123; width: 200px; height: 200px; background-color: aqua; float: left; &#125; &lt;/style&gt; 我们来看效果 当给父级一个float:left;之后，父级的高度也被撑开了，但是这种做法使得父级也脱离了文档流，虽然方便，但是对页面的布局不是很友好，不易维护。 以上就是我总结的五种清除浮动的方法，可能有些地方总结不到位，有则指出，无则加冕，感谢！","categories":[],"tags":[]},{"title":"http深入浅出--http请求","slug":"学习笔记一--Http请求","date":"2019-04-08T02:39:39.000Z","updated":"2019-04-08T03:02:12.858Z","comments":true,"path":"2019/04/08/学习笔记一--Http请求/","link":"","permalink":"https://www.xjt5213.club/2019/04/08/学习笔记一--Http请求/","excerpt":"","text":"HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务，HTTP目前协议的版本是1.1.HTTP是一种无状态的协议，无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP使用内容类型，是指Web服务器向Web浏览器返回的文件都有与之相关的类型。所有这些类型在MIME Internet邮件协议上模型化，即Web服务器告诉Web浏览器该文件所具有的种类，是HTML文档、GIF格式图像、声音文件还是独立的应用程序。大多数Web浏览器都拥有一系列的可配置的辅助应用程序，它们告诉浏览器应该如何处理Web服务器发送过来的各种内容类型。 HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：1,建立TCP连接在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80 2,Web浏览器向Web服务器发送请求命令一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令 例如：GET/sample/hello.jsp HTTP/1.1 3,Web浏览器发送请求头信息浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 4,Web服务器应答客户机向服务器发出请求后，服务器会客户机回送应答。eg: HTTP/1.1 200 OK 5，Web服务器应答头信息正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 6,Web服务器向浏览器发送数据Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 7,Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"元素js获取css样式","slug":"原生js获取css样式","date":"2019-04-08T02:39:39.000Z","updated":"2019-04-10T03:18:25.769Z","comments":true,"path":"2019/04/08/原生js获取css样式/","link":"","permalink":"https://www.xjt5213.club/2019/04/08/原生js获取css样式/","excerpt":"","text":"最近在写js代码的时候碰到了一个问题：用原生js并不能完全获取css样式属性。 1，内部样式表情况12document.getElementsByTagName(\"div\")[0].style.backgroundColor=\"green\"; //可以写入样式console.log(document.getElementsByTagName(\"div\")[0].style.width); //不能够获取样式属性 当用内部样式表的时候用这种方式的时候只能给css写入样式，并不能获取css样式。 2，内联样式情况12document.getElementsByTagName(\"div\")[0].style.backgroundColor=\"green\"; //可以写入样式console.log(document.getElementsByTagName(\"div\")[0].style.width); //能够获取样式属性 当使用内部样式表的时候，采用上面的js代码既可以获取样式属性，还可以给标签写入样式，但是使用内联样式的话会使得html代码显得很繁琐，没有规则，所以不推荐。 后来在网上查找了一些方法，发现了几种解决办法 方法一，使用window.getComputedStyle(参数一，参数二); 参数一：元素，参数二：当前元素的伪类，一般写null 12var divs=document.getElementsByTagName(\"div\")[0];console.log(window.getComputedStyle(divs,null).width); //获取宽度 这个方法在ie6-8上面不兼容，获取的内容为只读，并不能写入，所以我又找了一种方法 方法二，在ie上使用currentStyle属性","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.xjt5213.club/tags/学习笔记/"}]},{"title":"利用oneindex将onedrive打造成一个在线查看和下载文件的网盘","slug":"oneindex教程","date":"2019-04-07T12:03:21.000Z","updated":"2019-04-07T15:07:34.541Z","comments":true,"path":"2019/04/07/oneindex教程/","link":"","permalink":"https://www.xjt5213.club/2019/04/07/oneindex教程/","excerpt":"","text":"之前弄了一个onedrive账号，专门用来存一些电影，容量是5T，挺大的，用oneindex来将onedrive打造成一款可以在线观看和下载视频或者文件的一个小网站最好不过了 1，注册免费空间我用的是000webhost,所以我就拿这个来做了，附上注册链接：https://www.000webhost.com/free-website-sign-up 填写邮箱和密码就可以注册了，是不是非常简单…….. 2，网站后台接下来登陆进入后台会看到大概如图所示的样子，点击Manage Websites管理网站 点进去之后就是这个样子 ,然后点击File manager 出现这个 点击Upload files now 出现下图 3，oneindex部署先附上oneindex下载地址:https://github.com/donwa/oneindex 下载完成后,点击这个上传按钮把刚下的压缩包上传即可 注意：是上传至public_html文件夹下 上传完了之后，网站目录下就会出现这个压缩包了 然后右键单击压缩包解压 注意：还是解压至public_html目录下，可能因为某些原因压缩包解压不了，那么只能在本地解压了，然后把文件和文件夹一个一个地上传到该目录下，注意空文件夹也要上传哦 解压完或者上传完之后的文件大概是这个样子的 这个时候oneindex就部署完了 4，oneindex设置点击你的网址就会看到oneindex的设置界面了 下一步即可 然后获取应用id和机密分别填入第一栏和第二栏，第三栏不动 下一步。 绑定账号之后刷新你的网址就可以了 安装完成后可以通过后台登录对OneIndex进行管理 后台网址：你的原有网址上+/?/admin即可，初次登陆需要密码，默认密码是oneindex 上传文件到你的onedrive就可以在这个网站上同步显示了，如果是视频可以在线观看 5，指定文件夹加密如果你要给你的网站加密码，只有输入密码才能访问的话，win+R输入cmd 进入到你的桌面路径 在弹出的命令行输入echo 你设置的密码-&gt;password回车 在你的桌面会出现一个后缀为.password的文件，把这个文件放入你想加密的文件夹里面，到oneindex后台刷新缓存之后重新进入你的网站就会要求输入密码访问了。 6，文件上传上传文件的话直接用onedrive上传即可，刷新你的网站即可看到上传的文件。","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.xjt5213.club/tags/教程/"}]},{"title":"自建爬梯教程","slug":"爬梯教程","date":"2019-04-06T09:37:08.000Z","updated":"2019-04-08T09:50:56.135Z","comments":true,"path":"2019/04/06/爬梯教程/","link":"","permalink":"https://www.xjt5213.club/2019/04/06/爬梯教程/","excerpt":"","text":"之前自建爬梯的时候老是自己在网上找教程，非常啰嗦，所以写一篇搭建教程，为了以后的方便吧 1，注册vps首先你得有一个vps,至于是什么vps,本人不才，用的vultr，其实很多人都说vultr现在不好用了，过于泛滥，其实我觉得还行吧，可能是挺早之前买的缘故吧，听说后面买的比较容易被盯上。话不多说，开始上教程。首先，去注册一个vultr账号，其他的vps也一样需要注册账号，附上链接：https://www.vultr.com/然后在下图中填上你要注册的邮箱和密码点击Create Account就可以了,是不是特别简单。 2，充值在注册完成之后，就要给vultr充值了，用来购买套餐，vultr充值方式比较多，支持国内的支付宝和微信支付，首次登陆之后出现的界面就是充值界面了,选择你需要的充值方式进行充值即可 选择好充值方式和充值金额之后，点击下方的充值按钮进行支付就行了 3，套餐选择充值完成之后，点击左侧栏的第一个进行服务器购买 1，Server Location：是选择机房的位置，一般来说是离大陆越近越好，我选择的是日本机房，根据你们的情况自行选择即可 2,Server Type:是选择vps需要装的系统,一般来说选择centos或者Debian就可以了，我选择的是Debian9x64的，你们根据实际情况自行选择 3,Server Size:这里选择服务器的内存和月流量，如果你是一个人用的话推荐月付$3.5的或者$5的套餐即可 上面步骤执行完之后，下面的那些内容就不用管了，直接点击最下方的Deploy now即可 等待几分钟之后会出现下图所示点击服务器，会进入到详细页面,下图所示是一般需要了解的地方 4，登陆vps后台进行配置这里我们需要下载一个软件叫xshell,xftp也可以，我用的是xshell,你们根据自己的需要自行选择，附上链接https://www.netsarang.com/zh/free-for-home-school/这个是免费版，填上你的姓名和邮箱之后会把下载链接发送到你的邮箱进行下载即可，下载完之后安装打开,点击新建 上面填入你的主机名，即IP地址，填完之后点击左侧的用户身份验证 验证之后会跳到另一个页面，上面填写你的用户名root，和密码（密码在vps详情页面信息可以看到，教程上面有截图），填完之后点击下方的连接即可,在之后弹出的对话框中选择一次性接受就可以了 不出意外的话，右侧的命令行最下方会出现root字样的一行，说明你成功登陆了 5，脚本安装(敲黑板，重点来了！！！！)成功登陆之后，就可以开始梯子的脚本安装了，我用的是GitHub上一位大牛的一键脚本(教程最后附上链接，有需要的朋友可以去看看)，一键傻瓜式安装即可，在命令行输入以下命令然后回车安装即可 5.1安装&amp;更新命令1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh 5.2自检命令（没啥用，可以省略）1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/self-check.sh &amp;&amp; bash self-check.sh 5.3卸载命令1wget -q -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/SSR-Bash-Python/master/install.sh &amp;&amp; bash install.sh uninstall 执行完上面的安装命令之后，然后在命令行输入ssr就可以运行脚本了,输入对应的数字就可以进行操作了 输入数字6回车,会提示输入用户名，密码，流量（每输入一个都要回车哦） 上面的步骤做完之后，一个梯子节点就生成了，往上拉一点，应该会出现下图相似的信息,复制标注的这段代码。 6，节点的使用6.1,手机使用如果你想在手机上使用的话。下载这个软件。下载地址：https://github.com/shadowsocksrr/shadowsocksr-latest-bin-backup/raw/master/Shadowsocksr-android-3.4.0.5.apk下载完成后打开 点击右下角+号，有个从剪切板导入，把刚刚复制的代码导入就行了，注意路由选择绕过局域网及中国大陆地址，不然访问国内的软件也会走vps流量哦 6.2，电脑使用如果你想在电脑上使用的话。下载这个软件。下载地址：https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip下载完成后解压，打开解压的文件夹，双击如图所示的图标之后右下角的任务栏会有小飞机的图标，鼠标右键单击这个图标，会有剪切板批量导入ssr:链接，还是复制刚才那段代码选择导入即可，导入完成之后注意系统代理模式选择PAC,代理规则选择绕过局域网和大陆即可 本教程的一键安装脚本由GitHub大佬提供，附上大佬链接https://github.com/FunctionClub/SSR-Bash-Python有需要的朋友可以去看看哦 本人第一次写教程，写的不好的地方欢迎在下方提出，以便以后可以改进，感谢哦","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.xjt5213.club/tags/教程/"}]},{"title":"开篇随笔","slug":"开篇随笔","date":"2019-04-01T09:19:37.000Z","updated":"2019-04-05T05:08:23.057Z","comments":true,"path":"2019/04/01/开篇随笔/","link":"","permalink":"https://www.xjt5213.club/2019/04/01/开篇随笔/","excerpt":"","text":"历经了各种艰难险阻（其实是自己太水），才完成这个blog的搭建，可以说是一个小小白了，搭建的过程中各种碰壁，不过最终还是完了，感觉内心还是蛮有成就感的，最近在开始接触前端知识，以后这个地方就作为我写一点学习笔记的地方吧，分享算不上，前面说了是小小白哈哈哈。目前大四，正处于找工作的黄金时期，其实静下心来学习是一件非常不容易的事情，当你的同学室友都纷纷出去找工作实习去了，而你还在上课，其实我的内心是非常焦灼的，然而没办法。只恨当初在学校的时候没有好好学习，手动留下悔恨的泪水表情包。至于为什么选择入前端这个行业，其实我自己也说不清，通俗点来讲的话是比较容易入门吧。其实在这之前自学过一段时间java，说说自学的感想吧，每天看视频，码代码，刚开始还是挺有兴趣的，可是到后来慢慢的就坚持不下去了，没有学习的氛围真的会让我坚持不下去，不知道你们会不会这样，就这样自学了不到一个月就不了了之了，然后就转前端了。。。。再讲一下去年秋招面试的各种经历吧，总结成四个字就是四处碰壁。当时刚开始的想法是找一个开发岗位的工作，信心满满，没错是梁静茹给我的勇气，跑各大学校的招聘会，在现场跟面试官交流的过程中，面试官问我有没有做过项目，我说没有。。。。。然后又问了一些关于框架的知识，我都是一脸懵，然后把简历留在那里说等通知，自己灰溜溜的走了，后来才意识到自己在这方面的不足，基本上每次面试都逃不过这两个问题。当时就感觉有点人生充满了绝望，当时是出于这样一种情况，想找一个好工作，可是水平又打不到。后来于是降低了标准，不找开发岗了，找一个技术支持岗吧，又开始在各大招聘网站上广撒网，等面试通知，后来找到一个相关工作，整天坐在电脑面前帮客户解决各种售前售后问题，一个人得照看三台电脑，工作了刚好一个星期，突然某一天快下班的时候被人事经理叫过去谈话，说我一个人照看三台电脑有点吃力，可能是不太适合这份工作，so……我第一次被炒……也没有很失望，本来我自己就不喜欢那份工作，无所谓。然后就回家过年了哈哈哈哈，心真大。说真的 ，找一份自己感兴趣的工作真的非常重要。诶！不说了，都是泪。其实我感觉我对计算机挺感兴趣的，每次做完一个东西都感觉特别有成就感，尽管在某些大牛眼里是一个非常普通的东西。但是同时也不知道自己是不是真的适合干这个行业，还是那句话，不管结果如何，自己尽力了就好。 ps:不知道写点啥了，以后想起来再写吧，希望最后活成自己想要的样子。","categories":[],"tags":[]}]}